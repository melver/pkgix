#!/usr/bin/env bash

#
# pkgix: Prefix environment and simple package management tool.
#
# Copyright (C) 2012, Marco Elver <me AT marcoelver.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

set -o errtrace
set -o errexit
set -o nounset

##
# Constants
#
PROG_VERSION="0.3.0"
PROGNAME="pkgix"
DB_PREFIX="var/lib/${PROGNAME}/local"
LOG_FILE="var/log/${PROGNAME}.log"
LOCK_FILE="var/lock/${PROGNAME}.lock"
URL_SEP=";"
METAPKG_DUMMY="_dummy"
readonly PROG_VERSION PROGNAME DB_PREFIX LOG_FILE URL_SEP METAPKG_DUMMY

##
# Exit codes
#
EXIT_OK=0
EXIT_ERR=1
EXIT_INVALID_OPTION=2
EXIT_USER_ABORT=3
readonly EXIT_OK EXIT_ERR EXIT_INVALID_OPTION EXIT_USER_ABORT

##
# Function return codes
#
RET_OK=0
RET_ERR=1
RET_INVALID_OPTION=2
RET_USER_ABORT=3
readonly RET_OK RET_ERR RET_INVALID_OPTION RET_USER_ABORT

##
# Configurable variables, settable via environment
#
: ${PKGIX_REPO_URLS:="${HOME}/${PROGNAME}-repo/pkgs"}
: ${PKGIX_SHELL:="$SHELL"}
: ${PKGIX_FETCH:="wget -O %s"}
: ${PKGIX_COLOR:=1}

# PKGIX_ROOT: If set, PKGIX_ROOT is being used as the default root
#	(no need to specify for each command).
#
# PKGIX_BUILD_DIR: If set, uses ${PKGIX_BUILD_DIR}/{pkgix-build,pkgix-install}
#	to build packages in, instead of default <prefix-root>/{.pkgix-build,.pkgix-install}.

##
# Color config
#
# Check if color is enabled and we have stderr/in on terminal
if [[ "$PKGIX_COLOR" != "0" && -t 2 && -t 1 ]]; then
	# Check if we have tput
	if type -p tput > /dev/null; then
		Crst="$(tput sgr0)"
		Cred="$(tput setaf 1)"
		Cgrn="$(tput setaf 2)"
		Cylw="$(tput setaf 3)"
		Cblu="$(tput setaf 4)"
		Cpur="$(tput setaf 5)"
		Ccyn="$(tput setaf 6)"
		_tput_bold="$(tput bold)"
		CredB="${_tput_bold}${Cred}"
		CgrnB="${_tput_bold}${Cgrn}"
		CylwB="${_tput_bold}${Cylw}"
		CbluB="${_tput_bold}${Cblu}"
		CpurB="${_tput_bold}${Cpur}"
		CcynB="${_tput_bold}${Ccyn}"
		unset _tput_bold
	else
		# Fallback
		Crst='\e[0m'
		Cred='\e[0;31m'
		Cgrn='\e[0;32m'
		Cylw='\e[0;33m'
		Cblu='\e[0;34m'
		Cpur='\e[0;35m'
		Ccyn='\e[0;36m'
		CredB='\e[1;31m'
		CgrnB='\e[1;32m'
		CylwB='\e[1;33m'
		CbluB='\e[1;34m'
		CpurB='\e[1;35m'
		CcynB='\e[1;36m'
	fi
else
	Crst=
	Cred=
	Cgrn=
	Cylw=
	Cblu=
	Cpur=
	Ccyn=
	CredB=
	CgrnB=
	CylwB=
	CbluB=
	CpurB=
	CcynB=
fi

##
# log_printf pkgix_root args...
#
log_printf() {
	local log_file="${1}/${LOG_FILE}"
	shift
	[[ ! -d "${log_file%/*}" ]] && mkdir -p "${log_file%/*}" || :
	printf "[$(date)] ""$@" >> "$log_file"
}

##
# printf wrappers
#
msg_printf() {
	printf "${Cpur}[${PROGNAME}]${Crst} ""$@" 1>&2
}

verbose_printf() {
	(( arg_verbose )) && msg_printf "$@" || :
}

error_printf() {
	msg_printf "${Cred}ERROR:${Crst} ""$@"
}

warning_printf() {
	msg_printf "${Cylw}WARNING:${Crst} ""$@"
}

##
# Sanitize environment variables (need *_printf)
#
if [[ -n "${PKGIX_BUILD_DIR:-}" ]]; then
	if [[ ! -d "$PKGIX_BUILD_DIR" ]]; then
		error_printf "PKGIX_BUILD_DIR='$PKGIX_BUILD_DIR' not a valid directory!\n"
		exit $EXIT_ERR
	fi

	PKGIX_BUILD_DIR="$(cd "$PKGIX_BUILD_DIR" && pwd)"
fi

##
# in_list needle hay...
#
in_list() {
	local needle="$1"
	shift

	local elem
	for elem in "$@"; do
		[[ "$elem" == "$needle" ]] && return $RET_OK || :
	done

	return $RET_ERR
}

##
# OS dependent functions
# Also set ostype and architecture (aliases to OS and arch name)
#
case "$OSTYPE" in
	*freebsd*|*FreeBSD*)
		ostype="freebsd"
		architecture="$(uname -m)"

		sha256checksum() {
			sha256 "$@"
		}

		find_printbase() {
			find "$@" | sed "s:^$1::" 
		}
		;;
	*|*linux*)
		ostype="$OSTYPE"
		architecture="$(uname -m)"

		sha256checksum() {
			sha256sum "$@"
		}

		find_printbase() {
			find "$@" -printf "%P\n"
		}
		;;
esac

##
# lock_root pkgix_root
# Checks for existing lock, creates a lock file in pkgix_root if not locked.
#
# Should not call from subshells!
#
lock_root() {
	local pkgix_root="$(cd "$1" && pwd)"
	local lock_file="${pkgix_root}/${LOCK_FILE}"
	if [[ -f "$lock_file" ]]; then
		error_printf "$lock_file exists!\n"
		return $RET_ERR
	fi

	[[ ! -d "${lock_file%/*}" ]] && mkdir -p "${lock_file%/*}" || :
	: > "$lock_file"
	trap "unlock_root '${pkgix_root}'" EXIT
	return $RET_OK
}

##
# unlock_root pkgix_root
#
unlock_root() {
	local pkgix_root="$(cd "$1" && pwd)"
	local lock_file="${pkgix_root}/${LOCK_FILE}"
	rm "$lock_file"
	trap - EXIT
}

##
# extract_archive path_to_archive
#
extract_archive() {
	local archive_name="${1:-}"

	if [[ -f "$archive_name" ]] ; then
		msg_printf "Extracting '$archive_name'...\n"

		case "$archive_name" in
			*.tar.bz2)  tar xjf "$archive_name"   ;;
			*.tar.gz)   tar xzf "$archive_name"   ;;
			*.tar.lzma) tar --lzma -xf "$archive_name" ;;
			*.tar.xz)   tar xJf "$archive_name"   ;;
			*.tar)      tar xf "$archive_name"    ;;
			*.tbz2)     tar xjf "$archive_name"   ;;
			*.tgz)      tar xzf "$archive_name"   ;;
			*.txz)      tar xJf "$archive_name"   ;;
			*.bz2)      bunzip2 "$archive_name"    ;;
			*.rar)      unrar x "$archive_name"    ;;
			*.gz)       gunzip "$archive_name"     ;;
			*.zip)      unzip "$archive_name"      ;;
			*.Z)        uncompress "$archive_name" ;;
			*.7z)       7z x "$archive_name"       ;;
			*)          error_printf "'$archive_name' cannot be extracted (format unknown) !\n" ; exit $EXIT_ERR ;;
		esac
	else
		error_printf "'$archive_name' is not a valid file !\n"
		exit $EXIT_ERR
	fi
}

##
# fetch url checksum_sha256 [file_name]
# Function for use in package description files.
#
fetch() {
	local url="${1:-}"
	local checksum_sha256="${2:-}"
	local file_name="${3:-${url##*/}}"

	if [[ -z "$url" ]]; then
		error_printf "Invalid URL\n"
		exit $EXIT_ERR
	fi

	if [[ ! -f "$file_name" ]]; then
		if [[ "$url" =~ ^/ ]]; then
			# Is a local path, just copy
			msg_printf "Copying '$url'...\n"
			if ! cp "$url" "$file_name" &> /dev/null; then
				error_printf "Copying '$url' failed!\n"
				exit $EXIT_ERR
			fi
		else
			local fetch_cmd
			printf -v fetch_cmd "$PKGIX_FETCH" "$file_name"
			msg_printf "Fetching '$url'...\n"
			if ! $fetch_cmd "$url"; then
				error_printf "Fetching '$url' failed!\n"
				exit $EXIT_ERR
			fi
		fi
	fi

	local file_checksum_sha256
	file_checksum_sha256=($(sha256checksum "$file_name"))
	file_checksum_sha256="${file_checksum_sha256[0]}"

	if [[ -n "$checksum_sha256" ]]; then
		if (( ! arg_ignore_checksums )); then
			if [[ "$file_checksum_sha256" != "$checksum_sha256" ]]; then
				error_printf "Checksum of '$file_name' ($file_checksum_sha256)\n    does not match ($checksum_sha256)!\n"
				exit $EXIT_ERR
			else
				msg_printf "Valid checksum: $file_name\n"
			fi
		else
			warning_printf "Ignoring checksum for '$file_name'...\n"
		fi
	else
		if (( ! arg_ignore_checksums )); then
			error_printf "No checksum for '$file_name' ($file_checksum_sha256)!\n"
			exit $EXIT_ERR
		else
			warning_printf "No checksum for '$file_name' ($file_checksum_sha256)!\n"
		fi
	fi
}

##
# fetch_extract url checksum [archive_name]
# Function for use in package description files.
#
fetch_extract() {
	local url="${1:-}"
	local checksum_sha256="${2:-}"
	local archive_name="${3:-${url##*/}}"

	fetch "$url" "$checksum_sha256" "$archive_name"
	extract_archive "$archive_name"
}

##
# remove_empty_dirs path [depth]
# Remove empty directories in path.
#
remove_empty_dirs() {
	local path="$1"
	local depth="${2:-}"
	local find_args
	[[ -z "$depth" ]] && find_args=() || find_args=("-maxdepth" "$depth")

	find "$path" "${find_args[@]:+${find_args[@]}}" -type d -empty -delete
}

##
# prompt_continue
# Prompt user for "Continue ? [Y/n]"
# Return code will be RET_OK for y and RET_ERR for n.
#
prompt_continue() {
	(( arg_noconfirm )) && return $RET_OK

	local answer

	printf "${CbluB}Continue ? [Y/n] ${Crst}"
	read answer

	if [[ ! "$answer" =~ ^[yY]|^$ ]]; then
		verbose_printf "User aborted.\n"
		return $RET_ERR
	fi

	return $RET_OK
}

##
# export_env pkgix_root
#
export_env() {
	[[ ! -d "${1:-}" ]] && return $RET_ERR
	local pkgix_root="$(cd "$1" && pwd)"

	if [[ -z "${PKGIX_ROOT:-}" ]]; then
		# Export so calls to pkgix don't need the root; appending, so that 
		# installing takes the first root.
		export PKGIX_ROOT="$pkgix_root"
	else
		# Check if this has already been exported
		# Also check CPATH, as I don't expect a user to set it for a pkgix root.
		[[ "$PKGIX_ROOT" =~ ^(.*:)?${pkgix_root}(:.*)?$ &&
			"$CPATH" =~ ^(.*:)?${pkgix_root}/include(:.*)?$ ]] && return $RET_OK

		export PKGIX_ROOT="$PKGIX_ROOT:${pkgix_root}"
	fi

	verbose_printf "Exporting environment: $pkgix_root\n"

	# Prepending to PATH
	export PATH="${pkgix_root}/bin:${PATH:-}"
	export PATH="${pkgix_root}/sbin:${PATH:-}"

	local library_path="${pkgix_root}/lib"

	# Don't necessarily want lib64/lib32 on the path, especially if the setup is pure,
	# therefore check and only add them if they exist.
	local libdir
	for libdir in lib64 lib32; do
		if [[ -d "${pkgix_root}/${libdir}" ]]; then
			library_path+=":${pkgix_root}/${libdir}"
		fi
	done

	# LD_LIBRARY_PATH is harmful, as it makes programs from the system use
	# the libraries found in $pkgix_root/lib, which is certainly not
	# considered stable.
	# For more info: http://xahlee.info/UnixResource_dir/_/ldpath.html

	# Instead, make programs include the correct search path when they are
	# compiled (--rpath).
	if [[ -z "${LD_RUN_PATH:-}" ]]; then
		export LD_RUN_PATH="${library_path}"
	else
		export LD_RUN_PATH="${library_path}:$LD_RUN_PATH"
	fi

	# And make the linker look in the right paths (-L)
	if [[ -z "${LIBRARY_PATH:-}" ]]; then
		export LIBRARY_PATH="${library_path}"
	else
		export LIBRARY_PATH="${library_path}:$LIBRARY_PATH"
	fi

	if [[ -z "${PKG_CONFIG_PATH:-}" ]]; then
		export PKG_CONFIG_PATH="${pkgix_root}/lib/pkgconfig"
	else
		export PKG_CONFIG_PATH="${pkgix_root}/lib/pkgconfig:$PKG_CONFIG_PATH"
	fi

	# C/C++ preprocessor search paths (-I)
	if [[ -z "${CPATH:-}" ]]; then
		export CPATH="${pkgix_root}/include"
	else
		export CPATH="${pkgix_root}/include:$CPATH"
	fi

	return $RET_OK
}

##
# cmd_showenv pkgix_root...
#
cmd_showenv() {
	local pkgix_root
	for pkgix_root in "$@"; do
		export_env "$pkgix_root" || :
	done

	# See export_env for why we are not exporting LD_LIBRARY_PATH

	case "$PKGIX_SHELL" in
		*csh)
			[[ -n "${PKGIX_ROOT:-}" ]] && echo "setenv PKGIX_ROOT \"$PKGIX_ROOT\"" || :
			[[ -n "${PATH:-}" ]] && echo "setenv PATH \"$PATH\"" || :
			[[ -n "${LD_RUN_PATH:-}" ]] && echo "setenv LD_RUN_PATH \"$LD_RUN_PATH\"" || :
			[[ -n "${LIBRARY_PATH:-}" ]] && echo "setenv LIBRARY_PATH \"$LIBRARY_PATH\"" || :
			[[ -n "${PKG_CONFIG_PATH:-}" ]] && echo "setenv PKG_CONFIG_PATH \"$PKG_CONFIG_PATH\"" || :
			[[ -n "${CPATH:-}" ]] && echo "setenv CPATH \"$CPATH\"" || :
			;;
		*)
			# Assume sh compatible shell (bash, zsh, ..)
			[[ -n "${PKGIX_ROOT:-}" ]] && echo "export PKGIX_ROOT=\"$PKGIX_ROOT\"" || :
			[[ -n "${PATH:-}" ]] && echo "export PATH=\"$PATH\"" || :
			[[ -n "${LD_RUN_PATH:-}" ]] && echo "export LD_RUN_PATH=\"$LD_RUN_PATH\"" || :
			[[ -n "${LIBRARY_PATH:-}" ]] && echo "export LIBRARY_PATH=\"$LIBRARY_PATH\"" || :
			[[ -n "${PKG_CONFIG_PATH:-}" ]] && echo "export PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH\"" || :
			[[ -n "${CPATH:-}" ]] && echo "export CPATH=\"$CPATH\"" || :
			;;
	esac
}

##
# is_pkg_pointer pkg_file
#
is_pkg_pointer() {
	[[ "$(wc -l < "$1")" =~ ^[^0-9]*[01][^0-9]*$ ]]
}

##
# source_pkg_file pkg_file
#
source_pkg_file() {
	local pkg_file="$1"

	if is_pkg_pointer "$pkg_file"; then
		local resolved_pkg_name="$(<$pkg_file)"

		if [[ -z "${resolved_pkg_name:-}" ]]; then
			error_printf "Empty package description file!\n"
			return $RET_ERR
		fi

		msg_printf "Points to $resolved_pkg_name\n"
		source_pkg "$resolved_pkg_name"
	else
		source "$pkg_file"
	fi
}

##
# source_pkg pkg_name
#
source_pkg() {
	local pkg_name="$1"
	local pkg_file
	local o_IFS="$IFS" ; IFS="$URL_SEP"

	# Don't set repo_url as local here, as it can then be used in the package
	# description files to get information about its source repository, and 
	# e.g., download extra files such as patches from the repo.
	for repo_url in $PKGIX_REPO_URLS; do
		pkg_file="${repo_url}/$pkg_name"

		case "$pkg_file" in
			http://*|https://*|ftp://*)
				local tmpfile="$(mktemp)"

				verbose_printf "Trying: $pkg_file\n"
				if wget -q -O "$tmpfile" "$pkg_file"; then
					verbose_printf "Source: ${Cgrn}$pkg_file${Crst}\n"
					source_pkg_file "$tmpfile"
					rm "$tmpfile"
					break
				fi
				rm "$tmpfile"
				;;
			*)
				verbose_printf "Trying: $pkg_file\n"
				if [[ -f "$pkg_file" ]]; then
					verbose_printf "Source: ${Cgrn}$pkg_file${Crst}\n"
					source_pkg_file "$pkg_file"
					break
				fi
				;;
		esac
	done

	IFS="$o_IFS"

	[[ -n "${version:-}" || "${metapkg:-}" == "$METAPKG_DUMMY" ]]
}

##
# sourced_pkg_call funcname [pkgix_root [install_dir]]
# Wrap sourced function call execution.
#
# Disable 'nounset' for calling sourced functions, as the complexity of package
# description files should be small enough to trade some code safety for
# convenience. Enable inside the functions if neccessary.
#
# Makes the following extra variables available to package description file:
#     prefix=pkgix_root
#     destdir=install_dir
#
# Otherwise potentially useful variables which are available from parent scope:
#     old_version, if package is being upgraded (see root_upgrade)
#
# Due to the way BASH behaves, propagating even local variables from a parent
# function to its children, ALL variables from parents will be available.
# However, as the function to be called is executed in a subshell, none of
# these variables can be affected after completion of sourced_pkg_call.
#
sourced_pkg_call() {
	local funcname=$1

	if ! type -p $funcname > /dev/null; then
		error_printf "Package file does not provide function: $funcname\n"
		exit $EXIT_ERR
	fi

	(
		# Optional Arguments, passed as globals
		if [[ -n "${2:-}" ]]; then
			prefix="$2"
			[[ -n "${3:-}" ]] && destdir="$3"
		fi

		(( ! arg_debug )) && set +o nounset || :
		$funcname
	)
}

##
# pkg_install pkgix_root pkg_name [reinstall]
#
pkg_install() {
	local pkgix_root="$1"
	local pkg_name="$2"
	local reinstall="${3:-0}"
	local is_reinstall=0

	if [[ ! -d "$pkgix_root" ]]; then
		error_printf "'$pkgix_root' is not a valid directory!\n"
		exit $EXIT_ERR
	fi

	local db_prefix="${pkgix_root}/${DB_PREFIX}/${pkg_name}"

	if [[ -f "${db_prefix}/version" ]]; then
		if (( ! reinstall )); then
			msg_printf "${Cgrn}$pkg_name${Crst} is available\n"
			return $RET_OK
		else
			is_reinstall=1
		fi
	fi

	msg_printf "${CcynB}=> $pkg_name${Crst}\n"

	(
		# Unset previous package variables, otherwise we might end in an endless loop
		# when resolving dependencies, or might even keep unset variables/functions.
		unset metapkg
		unset satisfied
		unset version
		unset license
		unset website
		unset description
		unset depends
		unset iscompat
		unset isinstalled
		unset build
		unset installenv
		unset postinstall
		unset forceinstall
		unset backup

		# Source package description file and try to traverse until a non-meta
		# package description is found.
		local next_pkg_name="$pkg_name" # preserve requested package name
		while :; do
			if ! source_pkg "$next_pkg_name"; then
				error_printf "Could not find valid package description file for '$next_pkg_name'!\n"
				exit $EXIT_ERR
			fi

			# Not a meta-package, continue normally
			[[ -z "${metapkg:-}" ]] && break

			# Is metapackage, check if satisfied
			if (( ! is_reinstall )) && sourced_pkg_call satisfied; then
				if (( ! arg_force )); then
					msg_printf "Metapackage '$next_pkg_name' satisfied.\n"
					exit $EXIT_OK
				else
					warning_printf "Forcing installation of metapackage '$next_pkg_name', despite satisfied...\n"
				fi
			fi

			# If this metapackage is only a dummy to check if a dependence is satisfied,
			# and the above 'satisfied' function failed, this is a dead end.
			if [[ "$metapkg" == "$METAPKG_DUMMY" ]]; then
				error_printf "Metapackage '$next_pkg_name' could not be satisfied!\n"
				exit $EXIT_ERR
			fi

			# Not satisfied and not a dummy, resolve this by trying to install
			# the suggested package.
			msg_printf "Metapackage: $next_pkg_name -> $metapkg\n"
			next_pkg_name="$metapkg"

			# Unset meta package fields, before next iteration of source_pkg
			unset metapkg
			unset version
			unset satisfied
			unset description
		done

		# Run all commands from package description file in subshells
		# so they can't clutter the namespace.

		if (( ! is_reinstall )) && sourced_pkg_call isinstalled; then
			if (( ! arg_force )); then
				msg_printf "'$pkg_name' already available outside of '$pkgix_root', skipping...\n"
				exit $EXIT_OK
			else
				msg_printf "Forcing installation of '$pkg_name', despite already available outside of '$pkgix_root'...\n"
			fi
		fi

		if ! sourced_pkg_call iscompat; then
			if (( ! arg_force )); then
				error_printf "'$pkg_name' is not compatible with your system!\n"
				exit $EXIT_ERR
			else
				warning_printf "Trying installation of '$pkg_name', despite system incompatibility...\n"
			fi
		fi

		if (( ! arg_nodeps )); then
			msg_printf "${Cgrn}$pkg_name (${version:-})${Crst} resolving dependencies...\n"
			local dep_name
			for dep_name in "${depends[@]:+${depends[@]}}"; do
				pkg_install "$pkgix_root" "$dep_name"
			done
		else
			warning_printf "Ignoring dependencies.\n"
		fi

		msg_printf "${Cgrn}$pkg_name (${version:-})${Crst} building...\n"

		local build_dir
		local install_dir
		if [[ -n "${PKGIX_BUILD_DIR:-}" ]]; then
			build_dir="${PKGIX_BUILD_DIR}/${PROGNAME}-build"
			install_dir="${PKGIX_BUILD_DIR}/${PROGNAME}-install"
		else
			build_dir="${pkgix_root}/.${PROGNAME}-build"
			install_dir="${pkgix_root}/.${PROGNAME}-install"
		fi

		mkdir -p "$build_dir"
		mkdir -p "$install_dir"

		pushd "$build_dir" &> /dev/null

		# Setup cleanup trap, as this is executed in subshell, it does not
		# affect the parent shell's trap which will be executed normally on exit.
		local trap_cmd="{ popd &> /dev/null; rm -rf \"$install_dir\";"
		(( ! arg_keep_build_dir )) && trap_cmd+=" rm -rf \"$build_dir\";"
		trap_cmd+=" }"

		trap "$trap_cmd" EXIT

		if ! sourced_pkg_call build "$pkgix_root" "$install_dir"; then
			error_printf "Building '$pkg_name' failed! Aborting.\n"
			exit $EXIT_ERR
		fi

		msg_printf "${Cgrn}$pkg_name (${version:-})${Crst} installing into staging area...\n"

		if ! sourced_pkg_call installenv "$pkgix_root" "$install_dir"; then
			error_printf "Installation of '$pkg_name' failed! Aborting.\n"
			exit $EXIT_ERR
		fi

		if (( is_reinstall )); then
			# Remove after build/installenv, so that if building/installing
			# a package depends on itself it is used rather than the system
			# version (e.g., gcc, make).  If the system version should be used
			# again: remove->install manually.
			pkg_remove "$pkgix_root" "$pkg_name"
		fi

		# Create the list of files to be installed
		local staging_files_file="${build_dir}/.staging.files"
		: > "$staging_files_file"
		if [[ -d "${install_dir}/${pkgix_root}" ]]; then
			# As prefix is $pkgix_root, the complete folder structure from / is maintained inside $install_dir
			find_printbase "${install_dir}/${pkgix_root}" > "$staging_files_file"
		else
			warning_printf "Package did not install any files.\n"
		fi

		# Require files.backup file; can be empty.
		# Perform this step before moving files to .pkgnew!
		local backup_file="${build_dir}/.staging.files.backup"
		: > "$backup_file"
		local backup_path
		local backup_checksum_sha256
		for backup_path in "${backup[@]:+${backup[@]}}"; do
			# Only do checksum based backup with real files
			if [[ -f "${install_dir}/${pkgix_root}/${backup_path}" ]]; then
				backup_checksum_sha256=($(sha256checksum "${install_dir}/${pkgix_root}/${backup_path}"))
				backup_checksum_sha256="${backup_checksum_sha256[0]}"
			else
				backup_checksum_sha256=""
			fi

			echo "${backup_path}:${backup_checksum_sha256}" >> "$backup_file"
		done

		# Check for file conflicts before copying from install_dir to pkgix_root
		local pkgnew_files_file="${build_dir}/.pkgnew.files"
		: > "$pkgnew_files_file"
		if (( ! arg_force )); then
			msg_printf "${Cgrn}$pkg_name (${version:-})${Crst} checking for file conflicts...\n"

			while read path; do
				if [[ ! -d "${pkgix_root}/${path}" && -e "${pkgix_root}/${path}" ]]; then
					in_list "$path" "${forceinstall[@]:+${forceinstall[@]}}" && continue || :

					# Only if the file already exists in pkgix_root and in
					# the backup list, should it be installed as a .pkgnew file.
					if in_list "$path" "${backup[@]:+${backup[@]}}"; then
						mv "${install_dir}/${pkgix_root}/${path}" "${install_dir}/${pkgix_root}/${path}.pkgnew"
						echo "${path}.pkgnew" >> "$pkgnew_files_file"
						warning_printf "Installing '${path}' as '${path}.pkgnew'\n"
						continue
					fi

					error_printf "Conflict detected: ${path}\n"
					exit $EXIT_ERR
				fi
			done < "$staging_files_file"
		else
			warning_printf "Skipping file conflict check.\n"
		fi

		msg_printf "${Cgrn}$pkg_name (${version:-})${Crst} installing...\n"

		# Create installed database folders
		mkdir -p "${db_prefix}"

		# Use previously created list of files and pkgnew files
		cat "$staging_files_file" "$pkgnew_files_file" > "${db_prefix}/files"
		rm "$staging_files_file" "$pkgnew_files_file"

		# Use previously created list of backup files
		mv "$backup_file" "${db_prefix}/files.backup"

		# Perform actual installation
		if [[ -d "${install_dir}/${pkgix_root}" ]]; then
			cp -a "${install_dir}/${pkgix_root}"/* "${pkgix_root}"
		fi

		trap - EXIT
		popd &> /dev/null
		(( ! arg_keep_build_dir )) && rm -rf "$build_dir"
		rm -rf "$install_dir"

		# Run postinstall if available
		if type -p postinstall > /dev/null; then
			msg_printf "${Cgrn}$pkg_name (${version:-})${Crst} post-install...\n"
			if ! sourced_pkg_call postinstall "$pkgix_root"; then
				warning_printf "Post-installation step failed!\n"
			fi
		fi

		echo "${version:-}" > "${db_prefix}/version"
		[[ -z "${version:-}" ]] && warning_printf "Empty 'version' field in package description file of '$pkg_name'!\n"

		{
			echo "description=\"${description:-}\""
			echo "installdate=\"$(date)\""
			echo "website=\"${website:-}\""

			printf "license=("
			local license_elem
			for license_elem in "${license[@]:+${license[@]}}"; do
				printf " '%s'" "$license_elem"
			done
			printf " )\n"

			printf "depends=("
			local dep_name
			for dep_name in "${depends[@]:+${depends[@]}}"; do
				printf " '%s'" "$dep_name"
			done
			printf " )\n"
		} > "${db_prefix}/info"

		[[ -z "${description:-}" ]] && warning_printf "Empty 'description' field in package description file of '$pkg_name'!\n"
		[[ -z "${license[*]:+${license[*]}}" ]] && warning_printf "Empty 'license' field in package description file of '$pkg_name'!\n"
		[[ -z "${website:-}" ]] && warning_printf "Empty 'website' field in package description file of '$pkg_name'!\n"

		# The db file is important for upgrading packages in the order they were installed!
		# As the entries are not deleted upon removal, over time, a dependence ordering
		# is being built, so that if removed packages are reinstalled, upgrading still
		# works as before.
		local db_file="${pkgix_root}/${DB_PREFIX}.db"

		if [[ -f "$db_file" ]] && grep -q "^.|${pkg_name}$" "$db_file"; then
			sed -i "s:^.|${pkg_name}$:i|${pkg_name}:" "$db_file"
		else
			echo "i|$pkg_name" >> "$db_file"
		fi

		msg_printf "${CgrnB}$pkg_name (${version:-})${Crst} successfully installed.\n"
		log_printf "$pkgix_root" "$pkg_name (${version:-}) installed\n"
	) || exit $?

	return $RET_OK
}

##
# pkg_remove pkgix_root pkg_name
#
pkg_remove() {
	local pkgix_root="$1"
	local pkg_name="$2"
	local purge="${3:-0}"
	local db_prefix="${pkgix_root}/${DB_PREFIX}/${pkg_name}"
	local files_file="${db_prefix}/files"
	local backup_file="${db_prefix}/files.backup"
	local version_file="${db_prefix}/version"
	local info_file="${db_prefix}/info"
	local version="$(<"$version_file")"

	if [[ ! -f "$files_file" ]]; then
		error_printf "'$files_file' does not exist!\n"
		exit $EXIT_ERR
	fi

	# Create an empty files.backup file if it does not exist [backwards compatibility].
	if (( purge )) || [[ ! -f "$backup_file" ]]; then
		: > "$backup_file"
	fi

	msg_printf "${Cgrn}$pkg_name (${version})${Crst} removing...\n"

	local backup_path
	local backup_checksum_sha256
	local backup_checksum_sha256_f
	while read backup_path; do
		# (0) Check for changed files which require backup
		backup_checksum_sha256="${backup_path##*:}"
		backup_path="${backup_path%:*}"

		if [[ -f "${pkgix_root}/${backup_path}" ]]; then
			backup_checksum_sha256_f=($(sha256checksum "${pkgix_root}/${backup_path}"))
			backup_checksum_sha256_f="${backup_checksum_sha256_f[0]}"

			# If file changed, exclude from deletion
			if [[ "$backup_checksum_sha256" != "$backup_checksum_sha256_f" ]]; then
				verbose_printf "Keeping modified '${backup_path}'\n"
				echo "^${backup_path}$"
			fi
		else
			# Exclude by default
			echo "^${backup_path}$"
		fi
	done < "$backup_file" | grep -v -f - "$files_file" |
	while read filename; do
		# (1) First pass delete files and get directory depths

		if [[ ! -d "${pkgix_root}/$filename" ]]; then
			rm -f "${pkgix_root}/$filename"
		else
			# Get path depth for sorting: If we don't do this, directories
			# which are higher up in the hierarchy are being tried to be
			# deleted before its subdirectories, which could be empty, but
			# because the subdirectories still exist, the parent won't be
			# deleted.
			local o_IFS="$IFS"         ; IFS="/"
			local tmp=(${filename[@]}) ; IFS="$o_IFS"
			printf "${#tmp[@]}:${filename}\n"
		fi
	done | sort -rn |
	while read filename; do
		# (2) Then check for empty directories and delete if empty
		local filename="${filename#*:}"
		remove_empty_dirs "${pkgix_root}/$filename" 0
	done

	# Remove meta files
	rm "$files_file"
	rm "$backup_file"
	rm "$version_file"
	rm "$info_file"

	# Clean up db
	remove_empty_dirs "${pkgix_root}/${DB_PREFIX}"

	# Set package as removed
	sed -i "s:^.|${pkg_name}$:r|${pkg_name}:" "${pkgix_root}/${DB_PREFIX}.db"

	msg_printf "${CgrnB}$pkg_name (${version})${Crst} successfully removed.\n"
	log_printf "$pkgix_root" "$pkg_name (${version}) removed\n"
}

##
# cmd_install pkgix_root pkg_name...
#
cmd_install() {
	if [[ -z "${1:-}" ]]; then
		error_printf "You need to specify a pkgix root!\n"
		exit $EXIT_ERR
	fi

	local pkgix_root="$1"
	shift

	if [[ -z "${1:-}" ]]; then
		error_printf "You need to specify at least one package to install.\n"
		exit $EXIT_ERR
	fi

	if [[ ! -d "${pkgix_root}" ]]; then
		if ! mkdir -p "${pkgix_root}" 2> /dev/null; then
			error_printf "Could not create directory '$pkgix_root'!\n"
			exit $EXIT_ERR
		fi
	fi

	pkgix_root="$(cd "$pkgix_root" && pwd)"
	export_env "$pkgix_root"

	lock_root "$pkgix_root" || exit $EXIT_ERR

	msg_printf "Installing into $pkgix_root: $*\n"

	prompt_continue || exit $EXIT_USER_ABORT

	local pkg_name
	for pkg_name in "$@"; do
		pkg_install "$pkgix_root" "$pkg_name" "$arg_reinstall"
	done

	unlock_root "$pkgix_root"
}

##
# root_upgrade pkgix_root
#
root_upgrade() {
	local pkgix_root="$1"

	if [[ ! -f "${pkgix_root}/${DB_PREFIX}.db" ]]; then
		warning_printf "'$pkgix_root' is not a valid $PROGNAME root!\n"
		return $RET_INVALID_OPTION
	fi

	pkgix_root="$(cd "$pkgix_root" && pwd)"
	export_env "$pkgix_root"

	lock_root "$pkgix_root" || exit $EXIT_ERR

	msg_printf "Upgrading $pkgix_root ...\n"

	prompt_continue || return $RET_USER_ABORT

	grep "^i|" "${pkgix_root}/${DB_PREFIX}.db" |
	while read pkg_name; do
		local pkg_name="${pkg_name##i|}"
		local version_file="${pkgix_root}/${DB_PREFIX}/${pkg_name}/version"

		if [[ ! -f "$version_file" ]]; then
			warning_printf "Inconsistent database: no metadata for '$pkg_name'\n"
			continue
		fi

		old_version="$(<$version_file)"

		(
			if ! source_pkg "$pkg_name"; then
				warning_printf "Could not find package description file for '$pkg_name', skipping upgrade...\n"
			elif [[ "${version:-}" != "$old_version" ]] || (( arg_reinstall )); then
				msg_printf "${Cylw}Upgrading${Crst} $pkg_name ($old_version -> ${version:-})"
				(( ! arg_reinstall )) && printf "\n" || printf " - reinstall\n"
				log_printf "$pkgix_root" "upgrading $pkg_name ($old_version -> ${version:-})\n"

				pkg_install "$pkgix_root" "$pkg_name" 1
			else
				msg_printf "$pkg_name ($old_version) is up to date\n"
			fi
		) || exit $?  # Break out of pipe-subshell
	done || return $? # Take return code if pipe-subshell exited with errors

	msg_printf "Done upgrading.\n"

	unlock_root "$pkgix_root"
}

##
# cmd_upgrade pkgix_root...
#
cmd_upgrade() {
	if [[ -z "${1:-}" ]]; then
		error_printf "You need to specify at least one pkgix root!\n"
		exit $EXIT_ERR
	fi

	local pkgix_root
	local ret_code
	for pkgix_root in "$@"; do
		# Run nested, not to pollute subsequent upgrades with export_env
		# The environment should be set accordingly prior to upgrading!
		( root_upgrade "$pkgix_root" ) && ret_code=$? || ret_code=$?
		if (( ret_code != RET_OK && ret_code != RET_INVALID_OPTION && ret_code != RET_USER_ABORT )); then
			exit $EXIT_ERR
		fi
	done
}

##
# cmd_remove pkgix_root pkg_name...
#
cmd_remove() {
	local pkgix_root="${1:-}"
	shift || { error_printf "No targets specified!\n"; exit $EXIT_ERR; }

	if [[ ! -d "$pkgix_root" ]]; then
		error_printf "'$pkgix_root' is not a valid directory!\n"
		exit $EXIT_ERR
	fi

	pkgix_root="$(cd "$pkgix_root" && pwd)"

	lock_root "$pkgix_root" || exit $EXIT_ERR

	msg_printf "Removing from $pkgix_root: $*\n"
	prompt_continue || exit $EXIT_USER_ABORT
	
	local pkg_name
	for pkg_name in "$@"; do
		pkg_remove "$pkgix_root" "$pkg_name" "$arg_purge"
	done

	unlock_root "$pkgix_root"
}

##
# cmd_avail
#
cmd_avail() {
	local o_IFS="$IFS" ; IFS="$URL_SEP"

	local repo_url
	for repo_url in $PKGIX_REPO_URLS; do
		printf "${CbluB}-> ${CgrnB}${repo_url}${Crst}\n"
		case "$repo_url" in
			http://*|https://*|ftp://*)
				msg_printf "Listing packages for a HTTP repository is not supported!\n"
				;;
			*)
				# Don't show hidden files
				find_printbase "$repo_url" \( -type f -o -type l \) -a ! -name ".*" 2> /dev/null | sort |
				while read pkg_name; do
					if is_pkg_pointer "${repo_url}/$pkg_name"; then
						printf "%-42s %-18s %s\n" "$pkg_name" "->" "$(<"${repo_url}/$pkg_name")"
					else
						(
							source "${repo_url}/$pkg_name"
							printf "%-42s %-18s %s\n" "$pkg_name" "${version:-}" "${description:-}"
						)
					fi
				done
				;;
		esac
	done

	IFS="$o_IFS"
}

##
# cmd_list pkgix_root...
#
cmd_list() {
	local pkgix_root
	for pkgix_root in "$@"; do
		if [[ -d "$pkgix_root" ]]; then
			pkgix_root="$(cd "$pkgix_root" && pwd)"
			(( ! arg_quiet )) && printf "${CgrnB}${pkgix_root}${Crst}\n" 1>&2 || :

			if [[ -d "${pkgix_root}/${DB_PREFIX}" ]]; then
				find "${pkgix_root}/${DB_PREFIX}" -type f -name "version" | sort |
				while read version_file; do
					local pkg_name="${version_file##${pkgix_root}/${DB_PREFIX}/}"
					pkg_name="${pkg_name%%/version}"
					local info_file="${pkgix_root}/${DB_PREFIX}/${pkg_name}/info"

					if (( arg_quiet )); then
						echo "$pkgix_root $pkg_name"
					else
						(
							source "$info_file"
							printf "%-42s %-18s %s\n" "${pkg_name}" "$(<$version_file)" "${description:-}"
						)
					fi
				done
			fi
		fi
	done
}

##
# cmd_show pkgix_root pkg_name...
#
cmd_show() {
	local pkgix_roots=()

	if [[ "$*" =~ " -- " ]]; then
		while [[ "$1" != "--" ]]; do
			pkgix_roots+=("$1")
			shift || break
		done
	else
		pkgix_roots+=("${1:-}")
	fi

	shift || { error_printf "No targets specified!\n"; exit $EXIT_ERR; }

	local pkg_name
	local pkgix_root
	local db_prefix
	local files_file
	local version_file
	local info_file
	for pkg_name in "$@"; do
		for pkgix_root in "${pkgix_roots[@]}"; do
			if [[ ! -d "$pkgix_root" ]]; then
				error_printf "'$pkgix_root' is not a valid directory!\n"
				exit $EXIT_ERR
			fi

			pkgix_root="$(cd "$pkgix_root" && pwd)"
			db_prefix="${pkgix_root}/${DB_PREFIX}/${pkg_name}"
			files_file="${db_prefix}/files"
			version_file="${db_prefix}/version"
			info_file="${db_prefix}/info"

			if [[ -f "$version_file" && -f "$info_file" ]]; then
				if (( arg_list_files )); then
					local prefix_line=""
					(( ! arg_quiet )) && prefix_line="$pkg_name " || :
					local path
					while read path; do
						[[ -n "$path" ]] && echo "${prefix_line}${pkgix_root}/${path}" || :
					done < "$files_file"
				else
					source "$info_file"
					echo "$pkg_name ($(<$version_file)): ${pkgix_root}"
					echo " Description  : ${description:-}"
					echo " Website      : ${website:-}"
					echo " License      : ${license[*]:+${license[*]}}"
					echo " Depends      : ${depends[*]:+${depends[*]}}"
					echo " Install date : ${installdate:-}"

					echo
					unset description
					unset website
					unset license
					unset depends
					unset installdate
				fi

				# found, stop searching further pkgix_roots
				break
			else
				# indicate not yet found, continue search
				db_prefix=""
			fi
		done

		if [[ -z "$db_prefix" ]]; then
			error_printf "'$pkg_name' was not found!\n"
			exit $EXIT_ERR
		fi
	done
}

##
# cmd_chenv pkgix_root...
#
cmd_chenv() {
	local pkgix_root
	for pkgix_root in "$@"; do
		export_env "$pkgix_root"
	done

	msg_printf "Spawning shell\n"
	exec "$PKGIX_SHELL"
}

sanitize_repo_urls() {
	local old_repo_urls="$PKGIX_REPO_URLS"
	local o_IFS="$IFS" ; IFS="$URL_SEP"

	PKGIX_REPO_URLS=""

	local url
	for url in $old_repo_urls; do
		[[ "$url" =~ ^file:// ]] && url="${url##file://}"
		url=${url%%/}

		PKGIX_REPO_URLS+="${url};"
	done

	IFS="$o_IFS"
}

prog_usage() {
	echo "Usage: $PROGNAME [-r|--repo-urls] [-n|--noconfirm] [-v|--verbose] [--debug]"
	echo "             <command> [<args>]"
	echo
	echo "Commands available:"
	echo "    install    Install a package in a prefix environment"
	echo "    remove     Remove an installed package"
	echo "    upgrade    Upgrade a prefix environment"
	echo "    avail      List packages available to install"
	echo "    list       List installed packages"
	echo "    show       Show information about installed packages"
	echo "    showenv    Show prefix environment parameters"
	echo "    chenv      Switch to a prefix environment"
	echo
	echo "Options:"
	echo "   -r, --repo-urls"
	echo "       Specify additional package repository URL; use '$URL_SEP' to"
	echo "       separate multiple repositories. Currently supported protocols are:"
	echo "           file:// (default), http://, https://, ftp://"
	echo "   -n, --noconfirm"
	echo "       Proceed without asking the user for confirmation."
	echo "   -v, --verbose"
	echo "       Be more verbose."
	echo "   -q, --quiet"
	echo "       Be less verbose; some commands can show less information,"
	echo "       which makes their output more easily parsable by other tools."
	echo "   -d, --debug"
	echo "       Debug mode: enable nounset for package files"
	echo "   -h, --help"
	echo "       Display this help message."
	echo "   -V, --version"
	echo "       Display version information."
	echo
	echo "See '$PROGNAME help <command>' for more information on a command."
}

prog_version() {
	echo "$PROGNAME $PROG_VERSION"
	echo
	echo "Copyright (C) 2012, Marco Elver <me AT marcoelver.com>"
	echo
	echo "This is free software; see the source for copying conditions."
	echo "There is NO WARRANTY, to the extent permitted by law."
}

##
# trap_ERR errcode lineno command [traceback...]
#
trap_ERR() {
	local errcode="$1"
	local lineno="$2"
	local command="$3"
	shift 3
	local traceback=""

	[[ -n "$*" ]] && printf -v traceback "\n    ${CredB}=>${Crst} in %s" "$@"
	error_printf "line ${lineno} - '$command' failed (code=${errcode})${traceback}\n"
	exit 42
}

reset_traps() {
	trap '{ msg_printf "TERM signal caught, exiting...\n"; exit 42; }' TERM HUP QUIT
	trap '{ msg_printf "User aborted.\n"; exit 42; }' INT
	trap 'trap_ERR "$?" "$LINENO" "$BASH_COMMAND" "${FUNCNAME[@]:+${FUNCNAME[@]}}"' ERR
}

reset_traps

# Get command line options
arg_verbose=0
arg_quiet=0
arg_noconfirm=0
arg_debug=0

while :; do
	case "${1:-}" in
		-r|--repo-urls)
			[[ -z "${2:-}" ]] && { prog_usage; exit $EXIT_INVALID_OPTION; }

			PKGIX_REPO_URLS="${2}${URL_SEP}${PKGIX_REPO_URLS}"
			shift
			;;
		-v|--verbose) arg_verbose=1 ;;
		-q|--quiet) arg_quiet=1 ;;
		-n|--noconfirm) arg_noconfirm=1 ;;
		-d|--debug) arg_debug=1 ;;
		-h|--help) prog_usage; exit $EXIT_OK ;;
		-V|--version) prog_version; exit $EXIT_OK ;;
		*) break ;;
	esac
	shift
done

sanitize_repo_urls

cmd="${1:-}"
shift || :
case "$cmd" in
	install|upgrade)
		arg_force=0
		arg_nodeps=0
		arg_reinstall=0
		arg_keep_build_dir=0
		arg_ignore_checksums=0

		while :; do
			case "${1:-}" in
				-f|--force) arg_force=1 ;;
				-d|--nodeps) arg_nodeps=1 ;;
				-r|--reinstall) arg_reinstall=1 ;;
				-k|--keep-build-dir) arg_keep_build_dir=1 ;;
				--ignore-checksums) arg_ignore_checksums=1 ;;
				*) break ;;
			esac
			shift
		done

		;;& # Evaluate next statements!
	remove)
		arg_purge=0

		while :; do
			case "${1:-}" in
				-P|--purge) arg_purge=1 ;;
				*) break ;;
			esac
			shift
		done

		;;&
	show)
		arg_list_files=0

		while :; do
			case "${1:-}" in
				-l|--list) arg_list_files=1 ;;
				*) break ;;
			esac
			shift
		done
		;;&
	install|remove)
		if [[ -z "${PKGIX_ROOT:-}" ]]; then
			cmd_$cmd "$@"
		else
			# Commands which can only accept one root, pass first one only
			# Remove leading ':'
			args_root="${PKGIX_ROOT##:}"
			cmd_$cmd "${args_root%%:*}" "$@"
		fi
		;;
	upgrade|list|show|showenv|chenv)
		if [[ -z "${PKGIX_ROOT:-}" ]]; then
			cmd_$cmd "$@"
		else
			o_IFS="$IFS" ; IFS=":"
			args_root=(${PKGIX_ROOT[@]})
			IFS="$o_IFS" ; unset o_IFS

			case "$cmd" in
				show) cmd_$cmd "${args_root[@]}" -- "$@" ;;
				*)    cmd_$cmd "${args_root[@]}" "$@" ;;
			esac
		fi
		;;
	avail)
		cmd_$cmd "$@"
		;;
	help)
		case "${1:-}" in
			install|upgrade)
				echo "Usage: $PROGNAME $1 [-f|--force] [-d|--nodeps] [-r|--reinstall]"
				echo "                     [-k|--keep-build-dir] [--ignore-checksums]"

				if [[ "$1" == "install" ]]; then
					echo "                     <pkgix-root> <pkgs>..."
				else
					echo "                     <pkgix-roots>..."
				fi

				echo
				echo "Options:"
				echo "    -f, --force"
				echo "        Force installation of programs that are: already available outside of"
				echo "        <pkgix-roots>; satisfied metapackages; incompatible with the current system;"
				echo "        conflicting with already installed files."
				echo "        Also forces overwriting files which were normally preserved (see backup)."
				echo "    -d, --nodeps"
				echo "        Ignore dependenciy check and do not install dependencies."
				echo "    -r, --reinstall"
				echo "        Reinstall non-dependency, explicitly selected packages. When upgrading,"
				echo "        reinstall all installed packages."
				echo "    -k, --keep-build-dir"
				echo "        Keeps the build directory."
				echo "    --ignore-checksums"
				echo "        Ignores checksums for remotely fetched files."
				;;
			remove)
				echo "Usage: $PROGNAME $1 [-P|--purge]"
				echo
				echo "Options:"
				echo "    -P, --purge"
				echo "        Force removal of all installed files, even those marked for backup."
				;;
			show)
				echo "Usage: $PROGNAME $1 [-l|--list] (<pkgix-roots>... --|<pkgix-root>) <pkgs>..."
				echo
				echo "Options:"
				echo "    -l, --list"
				echo "        List installed package files."
				;;
			list|showenv|chenv)
				echo "Usage: $PROGNAME $1 <pkgix-roots>..."
				;;
			avail)
				echo "No further information available."
				;;
			help)
				echo "Usage: $PROGNAME $1 <command>"
				;;
			*)
				echo "Please specify valid command."
				exit $EXIT_INVALID_OPTION
				;;
		esac
		;;
	*)
		prog_usage
		exit $EXIT_INVALID_OPTION
		;;
esac

exit $EXIT_OK

# vim: set noet :
