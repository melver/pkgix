#!/usr/bin/env bash

#
# pkgix: Prefix environment and simple package management tool.
#
# Copyright (C) 2012, Marco Elver <me@marcoelver.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

set -o errtrace
set -o errexit
set -o nounset

#============================================================================
# Constants
#
PROG_VERSION="0.3.0"
PROGNAME="pkgix"
DB_PREFIX="var/lib/${PROGNAME}/local"
LOG_FILE="var/log/${PROGNAME}.log"
LOCK_FILE="var/lock/${PROGNAME}.lock"
REMOTE_AVAIL_FILE=".avail"
URL_SEP=";"
METAPKG_DUMMY="_dummy"
REASON_EXPLICIT="explicit"
REASON_DEPENDENCY="dependency"
readonly PROG_VERSION PROGNAME DB_PREFIX LOG_FILE URL_SEP METAPKG_DUMMY
readonly REASON_EXPLICIT REASON_DEPENDENCY

#============================================================================
# Exit codes
#
EXIT_OK=0
EXIT_ERR=1
EXIT_INVALID_OPTION=2
EXIT_USER_ABORT=3
readonly EXIT_OK EXIT_ERR EXIT_INVALID_OPTION EXIT_USER_ABORT

#============================================================================
# Function return codes
#
RET_OK=0
RET_ERR=1
RET_INVALID_OPTION=2
RET_USER_ABORT=3
readonly RET_OK RET_ERR RET_INVALID_OPTION RET_USER_ABORT

#============================================================================
# abspath path
# Get absolute path; normalizes the path if dir or file exists.
#
# Declared here, as it can then be used in defining default values for
# configurable variables, or can even be used in the RC-file.
#
abspath() { #{{{
	local path="$1"

	if [[ -d "$path" ]]; then
		( cd "$path" && pwd )
	elif [[ -f "$path" ]]; then
		echo "$( cd "${path%/*}" && pwd )/${path##*/}"
	else
		# Doesn't seem to exist, try best guess
		if [[ "$path" =~ ^/ ]]; then
			echo "$path"
		else
			echo "$(pwd)/${path}"
		fi
	fi
} #}}}

#============================================================================
# Configurable variables, settable via environment or RC-file
#
## Variables with a default value (see below):
#
# PKGIXRC: RC-file, which is sourced and can be used to set configurable
# variables.
#
# PKGIX_REPOS: List of repository URLs; either a URL_SEP separated string of
# URLs or an array. Note that additional URLs specified with `-r` are prepended
# if this is a string, and appended if it's an array.
#
# PKGIX_SHELL: Which shell should be invoked for chenv and is also used to
# determine the showenv format.
#
# PKGIX_FETCH: External program to download files.
#
# PKGIX_COLOR: Set to 1 (default) for colored output, 0 for color-less output.
#
# PKGIX_UPGRADE_IGNORE: An array of package names, which should be ignored on
# upgrade. Can only be set via the RC-file.
#
## Variables without a default value:
#
# PKGIX_PREFIX: If set, PKGIX_PREFIX is being used as the default prefix (no need to
# specify for each command).
#
# PKGIX_BUILD_DIR: If set, uses ${PKGIX_BUILD_DIR}/{pkgix-build,pkgix-install}
# to build packages in, instead of the default of
# <prefix>/{.pkgix-build,.pkgix-install}.
#
: ${PKGIXRC:="${HOME}/.${PROGNAME}rc"}

##
# Set variables which can only be set from the RC-file here, but need to be set
# even if the RC-file does not set them:
PKGIX_UPGRADE_IGNORE=()

##
# Set configurable variables from RC-file first, so we do not unnecessarily
# set some of these twice.
[[ -r "$PKGIXRC" ]] && source "$PKGIXRC" || :

##
# Set variable defaults which have not been defined by either environment or
# RC-file:
: ${PKGIX_SHELL:="$SHELL"}
: ${PKGIX_FETCH:="wget -O %s"}
: ${PKGIX_COLOR:=1}

# PKGIX_REPOS must be declared; check with declare -p, instead of ${..:-},
# so that an empty array will not be assigned anything else (in this case the
# first element would be set to the default).
if ! declare -p PKGIX_REPOS &> /dev/null; then
	[[ -d "${HOME}/${PROGNAME}-repo/pkgs" ]] && PKGIX_REPOS="${HOME}/${PROGNAME}-repo/pkgs" || PKGIX_REPOS=""
fi

#============================================================================
# Setup gettext ($"...")
# Need to set TEXTDOMAIN first, then TEXTDOMAINDIR -- see BASH 4.2 source
#
TEXTDOMAIN="$PROGNAME"
TEXTDOMAINDIR="$(abspath "${0%/*}/../share/locale")"

#============================================================================
# Color config
#
# Check if color is enabled and we have stderr/in on terminal
if [[ "$PKGIX_COLOR" != "0" && -t 2 && -t 1 ]]; then # {{{
	# Check if we have tput
	if type -p tput > /dev/null; then
		Crst="$(tput sgr0)"
		Cred="$(tput setaf 1)"
		Cgrn="$(tput setaf 2)"
		Cylw="$(tput setaf 3)"
		Cblu="$(tput setaf 4)"
		Cpur="$(tput setaf 5)"
		Ccyn="$(tput setaf 6)"
		_tput_bold="$(tput bold)"
		CredB="${_tput_bold}${Cred}"
		CgrnB="${_tput_bold}${Cgrn}"
		CylwB="${_tput_bold}${Cylw}"
		CbluB="${_tput_bold}${Cblu}"
		CpurB="${_tput_bold}${Cpur}"
		CcynB="${_tput_bold}${Ccyn}"
		unset _tput_bold
	else
		# Fallback
		Crst='\e[0m'
		Cred='\e[0;31m'
		Cgrn='\e[0;32m'
		Cylw='\e[0;33m'
		Cblu='\e[0;34m'
		Cpur='\e[0;35m'
		Ccyn='\e[0;36m'
		CredB='\e[1;31m'
		CgrnB='\e[1;32m'
		CylwB='\e[1;33m'
		CbluB='\e[1;34m'
		CpurB='\e[1;35m'
		CcynB='\e[1;36m'
	fi
else
	Crst=
	Cred=
	Cgrn=
	Cylw=
	Cblu=
	Cpur=
	Ccyn=
	CredB=
	CgrnB=
	CylwB=
	CbluB=
	CpurB=
	CcynB=
fi # }}}

#============================================================================
# printf wrappers
#
msg_printf() { #{{{
	printf "${Cpur}[${PROGNAME}]${Crst} ""$@" 1>&2
} #}}}

verbose_printf() { #{{{
	(( arg_verbose )) && msg_printf "$@" || :
} #}}}

error_printf() { #{{{
	msg_printf "${Cred}"$"ERROR:""${Crst} ""$@"
} #}}}

warning_printf() { #{{{
	msg_printf "${Cylw}"$"WARNING:""${Crst} ""$@"
} #}}}

#============================================================================
# die [printf_args..]
# Print message with error_printf then exit; if no message is specified, show a
# default error message.
#
die() { #{{{
	if (( $# > 0 )); then
		error_printf "$@"
	else
		error_printf $"An error occurred @ %s\n" "$(caller 0)"
	fi

	exit $EXIT_ERR
} #}}}

#============================================================================
# Sanitize environment variables (done here, as *_printf may be needed)
#
if [[ -n "${PKGIX_BUILD_DIR:-}" ]]; then
	if [[ ! -d "$PKGIX_BUILD_DIR" ]]; then
		die $"PKGIX_BUILD_DIR='%s' is not a valid directory!\n" "$PKGIX_BUILD_DIR"
	fi

	PKGIX_BUILD_DIR="$(abspath "$PKGIX_BUILD_DIR")"
fi

#============================================================================
# log_printf pkgix_prefix args...
#
log_printf() { #{{{
	local log_file="${1}/${LOG_FILE}"
	shift
	[[ ! -d "${log_file%/*}" ]] && mkdir -p "${log_file%/*}" || :
	printf "[$(date)] ""$@" >> "$log_file"
} #}}}

#============================================================================
# in_list needle hay...
#
in_list() { #{{{
	local needle="$1"
	shift

	local elem
	for elem in "$@"; do
		[[ "$elem" == "$needle" ]] && return $RET_OK || :
	done

	return $RET_ERR
} #}}}

#============================================================================
# OS dependent functions, detect platform and set variables accordingly
#
## pkgix tries to find defaults, but can be set from environment:
#
# CARCH: processor architecture, as the OS identified it
# CHOST: <arch>-<vendor>-<OS>-<libc>
#
## Always set by pkgix:
#
# ostype: consistend value representing the OS, regardless of variation
# architecture: consistent identifier of processor arch, regardless of OS
#
# {{{
if type -p sha256sum > /dev/null; then
	sha256checksum() {
		sha256sum "$1"
	}
elif type -p sha256 > /dev/null; then
	sha256checksum() {
		sha256 < "$1"
	}
else
	die $"No suitable SHA-256 command found!"
fi

if type -p md5sum > /dev/null; then
	md5checksum() {
		md5sum "$1"
	}
elif type -p md5 > /dev/null; then
	md5checksum() {
		md5 < "$1"
	}
else
	warning_printf $"No suitable MD5 command found; MD5 checksums not supported."
fi

case "$(uname -s)" in
	*[fF]ree[bB][sS][dD]*)
		: ${CARCH:="$(uname -m)"}
		ostype="freebsd"
		: ${CHOST:="${CARCH}-unknown-${ostype}-unknown"}

		case "$CARCH" in
			amd64) architecture="x86_64";;
			*) architecture="$CARCH" ;;
		esac

		find_printbase() {
			find "$@" | sed "s:^$1::" 
		}
		;;
	*[lL]inux*)
		: ${CARCH:="$(uname -m)"}
		ostype="linux"
		architecture="$CARCH"
		: ${CHOST:="${CARCH}-unknown-${ostype}-gnu"}

		find_printbase() {
			find "$@" -printf "%P\n"
		}
		;;
	*) # Guess
		: ${CARCH:="$(uname -m)"}
		ostype="$(uname -s)"
		architecture="$CARCH"
		: ${CHOST:="${CARCH}-unknown-${ostype}-unknown"}

		find_printbase() {
			find "$@" | sed "s:^$1::" 
		}
		;;
esac

show_platform_vars() {
	echo "CARCH=\"$CARCH\""
	echo "CHOST=\"$CHOST\""
	echo "ostype=\"$ostype\""
	echo "architecture=\"$architecture\""
	echo
}

#}}}

#============================================================================
# lock_prefix pkgix_prefix
# Checks for existing lock, creates a lock file in pkgix_prefix if not locked.
#
# Should not call from subshells!
#
lock_prefix() { #{{{
	local pkgix_prefix="$(abspath "$1")"
	local lock_file="${pkgix_prefix}/${LOCK_FILE}"
	if [[ -f "$lock_file" ]]; then
		error_printf $"%s exists!\n" "$lock_file"
		return $RET_ERR
	fi

	[[ ! -d "${lock_file%/*}" ]] && mkdir -p "${lock_file%/*}" || :
	: > "$lock_file"
	trap "unlock_prefix '${pkgix_prefix}'" EXIT
	return $RET_OK
} #}}}

#============================================================================
# unlock_prefix pkgix_prefix
#
unlock_prefix() { #{{{
	local pkgix_prefix="$(abspath "$1")"
	local lock_file="${pkgix_prefix}/${LOCK_FILE}"
	rm "$lock_file"
	trap - EXIT
} #}}}

#============================================================================
# extract_archive path_to_archive
#
extract_archive() { #{{{
	local archive_name="${1:-}"

	if [[ -f "$archive_name" ]] ; then
		msg_printf $"Extracting '%s'...\n" "$archive_name"

		case "$archive_name" in
			*.tar.bz2)  tar xjf "$archive_name"   ;;
			*.tar.gz)   tar xzf "$archive_name"   ;;
			*.tar.lzma) tar --lzma -xf "$archive_name" ;;
			*.tar.xz)   tar xJf "$archive_name"   ;;
			*.tar)      tar xf "$archive_name"    ;;
			*.tbz2)     tar xjf "$archive_name"   ;;
			*.tgz)      tar xzf "$archive_name"   ;;
			*.txz)      tar xJf "$archive_name"   ;;
			*.bz2)      bunzip2 "$archive_name"    ;;
			*.rar)      unrar x "$archive_name"    ;;
			*.gz)       gunzip "$archive_name"     ;;
			*.zip)      unzip "$archive_name"      ;;
			*.Z)        uncompress "$archive_name" ;;
			*.7z)       7z x "$archive_name"       ;;
			*)          die $"'%s' cannot be extracted (unknown format)!\n" "$archive_name" ;;
		esac
	else
		die $"'%s' is not a valid file !\n" "$archive_name"
	fi
} #}}}

#============================================================================
# fetch_remote url file_name
# Wrapper around remote-fetch utility.
# Download from url and save to file_name.
#
fetch_remote() { #{{{
	local url="$1"
	local file_name="$2"
	local fetch_cmd
	printf -v fetch_cmd -- "$PKGIX_FETCH" "$file_name"
	$fetch_cmd "$url"
} #}}}

#============================================================================
# verify_checksum checksum file_name
#
# checksum can be prefixed by <checksum-type>= to denote the checksum type.
# Supported types are: sha256 (default), md5
#
verify_checksum() { #{{{
	local checksum="$1"
	local file_name="$2"
	local file_checksum
	local checksum_fn

	case "$checksum" in
		md5=*)
			checksum="${checksum##md5=}"
			checksum_fn="md5checksum"
			;;
		*) # Default is sha256
			checksum="${checksum##sha256=}"
			checksum_fn="sha256checksum"
			;;
	esac

	file_checksum=($($checksum_fn "$file_name"))
	file_checksum="${file_checksum[0]}"

	if [[ -n "$checksum" ]]; then
		if (( ! arg_ignore_checksums )); then
			if [[ "$file_checksum" != "$checksum" ]]; then
				die $"Checksum of '%s' [%s] does not match [%s]!\n" "$file_name" "$file_checksum" "$checksum"
			else
				msg_printf $"Valid checksum: %s\n" "$file_name"
			fi
		else
			warning_printf $"Ignoring checksum for '%s'...\n" "$file_name"
		fi
	else
		if (( ! arg_ignore_checksums )); then
			die $"No checksum for '%s' [%s]!\n" "$file_name" "$file_checksum"
		else
			warning_printf $"No checksum for '%s' [%s]!\n" "$file_name" "$file_checksum"
		fi
	fi
} #}}}

#============================================================================
# fetch url [checksum] [file_name]
# Function for use in package description files.
#
fetch() { #{{{
	local url="${1:-}"
	local checksum="${2:-}"
	local file_name="${3:-${url##*/}}"

	[[ -z "$url" ]] && die $"Invalid URL\n" || :

	if [[ ! -f "$file_name" ]]; then
		if [[ "$url" =~ ^/ ]]; then
			# Is a local path, just copy
			msg_printf $"Copying '%s'...\n" "$url"
			if ! cp "$url" "$file_name" &> /dev/null; then
				die $"Copying '%s' failed!\n" "$url"
			fi
		else
			msg_printf $"Fetching '%s'...\n" "$url"
			if ! fetch_remote "$url" "$file_name"; then
				die $"Fetching '%s' failed!\n" "$url"
			fi
		fi
	fi

	verify_checksum "$checksum" "$file_name"
} #}}}

#============================================================================
# fetch_extract url checksum [archive_name]
# Function for use in package description files.
#
fetch_extract() { #{{{
	local url="${1:-}"
	local checksum="${2:-}"
	local archive_name="${3:-${url##*/}}"

	fetch "$url" "$checksum" "$archive_name"
	extract_archive "$archive_name"
} #}}}

#============================================================================
# remove_empty_dirs path [depth]
# Remove empty directories in path.
#
remove_empty_dirs() { #{{{
	local path="$1"
	local depth="${2:-}"
	local find_args
	[[ -z "$depth" ]] && find_args=() || find_args=("-maxdepth" "$depth")

	find "$path" "${find_args[@]:+${find_args[@]}}" -type d -empty -delete
} #}}}

#============================================================================
# prompt_continue
# Prompt user for "Continue ? [Y/n]"
# Return code will be RET_OK for y and RET_ERR for n.
#
prompt_continue() { #{{{
	(( arg_noconfirm )) && return $RET_OK

	local answer

	printf "${CbluB}"$"Continue ?"" [Y/n] ${Crst}"
	read answer

	if [[ ! "$answer" =~ ^[yY]|^$ ]]; then
		verbose_printf $"User aborted.\n"
		return $RET_ERR
	fi

	return $RET_OK
} #}}}

#============================================================================
# source_prefix_rc pkgix_prefix
# Source a prefix-specific RC-file.
#
# If the RC-file contains variables which are exported then they will be usable
# in e.g., chenv, while compiling; otherwise, the values set will only be
# valid in this session, but can be used to provide extra variables to
# package description files.
#
prefix_rc_sourced=0
source_prefix_rc() { #{{{
	(( prefix_rc_sourced )) && return || :
	local pkgix_prefix="$1"
	[[ ! -r "${pkgix_prefix}/etc/${PROGNAME}rc" ]] && return || :
	source "${pkgix_prefix}/etc/${PROGNAME}rc"
	prefix_rc_sourced=1
} #}}}

#============================================================================
# export_env pkgix_prefix [reset]
#
__old_env_saved=0
export_env() { #{{{
	local pkgix_prefix="$(abspath "$1")"
	local reset="${2:-0}"

	[[ ! -d "$pkgix_prefix" ]] && return $RET_ERR

	source_prefix_rc "$pkgix_prefix"

	if (( ! __old_env_saved )); then
		__old_env_saved=1
		__old_PKGIX_PREFIX="${PKGIX_PREFIX:-}"
		__old_PATH="${PATH:-}"
		__old_LD_RUN_PATH="${LD_RUN_PATH:-}"
		__old_LIBRARY_PATH="${LIBRARY_PATH:-}"
		__old_PKG_CONFIG_PATH="${PKG_CONFIG_PATH:-}"
		__old_CPATH="${CPATH:-}"
	elif (( reset )); then
		[[ -n "${__old_PKGIX_PREFIX}" ]] && PKGIX_PREFIX="${__old_PKGIX_PREFIX}" || unset PKGIX_PREFIX
		[[ -n "${__old_PATH}" ]] && PATH="${__old_PATH}" || unset PATH
		[[ -n "${__old_LD_RUN_PATH}" ]] && LD_RUN_PATH="${__old_LD_RUN_PATH}" || unset LD_RUN_PATH
		[[ -n "${__old_LIBRARY_PATH}" ]] && LIBRARY_PATH="${__old_LIBRARY_PATH}" || unset LIBRARY_PATH
		[[ -n "${__old_PKG_CONFIG_PATH}" ]] && PKG_CONFIG_PATH="${__old_PKG_CONFIG_PATH}" || unset PKG_CONFIG_PATH
		[[ -n "${__old_CPATH}" ]] && CPATH="${__old_CPATH}" || unset CPATH
	fi

	if [[ -z "${PKGIX_PREFIX:-}" ]]; then
		# Export so calls to pkgix don't need the prefix; appending, so that 
		# installing takes the first prefix.
		export PKGIX_PREFIX="$pkgix_prefix"
	else
		# Check if this has already been exported Also check CPATH, as I don't
		# expect a user to have set it for a prefix.
		[[ "$PKGIX_PREFIX" =~ ^(.*:)?"${pkgix_prefix}"(:.*)?$ &&
			"${CPATH:-}" =~ ^(.*:)?"${pkgix_prefix}"/include(:.*)?$ ]] && return $RET_OK

		export PKGIX_PREFIX="$PKGIX_PREFIX:${pkgix_prefix}"
	fi

	verbose_printf $"Exporting environment: %s\n" "$pkgix_prefix"

	local base_path
	local library_path
	for base_path in "${pkgix_prefix}" "${pkgix_prefix}/usr"; do

		library_path="${base_path}/lib"

		# Don't necessarily want lib64 or lib32 on the path, especially if the setup is pure,
		# therefore check and only add them if they exist.
		local libdir
		for libdir in lib64 lib32; do
			if [[ -d "${base_path}/${libdir}" ]]; then
				library_path+=":${base_path}/${libdir}"
			fi
		done

		# LD_LIBRARY_PATH is harmful, as it makes programs from the system use
		# the libraries found in $base_path/lib, which can result in strange
		# behaviour.
		# For more info: http://xahlee.info/UnixResource_dir/_/ldpath.html

		# Instead, make programs include the correct search path when they are
		# compiled (--rpath).
		if [[ -z "${LD_RUN_PATH:-}" ]]; then
			export LD_RUN_PATH="${library_path}"
		else
			export LD_RUN_PATH="${library_path}:$LD_RUN_PATH"
		fi

		# LD_RUN_PATH needs to be set for compilation even if the path does
		# not exist yet, as a package might install its own library in a
		# non-existent base-path and this needs to be encoded in the binaries;
		# the other variables are only useful if the paths they refer to exist.
		[[ ! -d "$base_path" ]] && continue || :

		# Prepending to PATH
		export PATH="${base_path}/bin:${PATH:-}"
		export PATH="${base_path}/sbin:${PATH:-}"

		# And make the linker look in the right paths (-L)
		if [[ -z "${LIBRARY_PATH:-}" ]]; then
			export LIBRARY_PATH="${library_path}"
		else
			export LIBRARY_PATH="${library_path}:$LIBRARY_PATH"
		fi

		if [[ -z "${PKG_CONFIG_PATH:-}" ]]; then
			export PKG_CONFIG_PATH="${base_path}/lib/pkgconfig"
		else
			export PKG_CONFIG_PATH="${base_path}/lib/pkgconfig:$PKG_CONFIG_PATH"
		fi

		# C/C++ preprocessor search paths (-I)
		if [[ -z "${CPATH:-}" ]]; then
			export CPATH="${base_path}/include"
		else
			export CPATH="${base_path}/include:$CPATH"
		fi

	done

	return $RET_OK
} #}}}

#============================================================================
# cmd_showenv pkgix_prefix...
#
cmd_showenv() { #{{{
	local pkgix_prefix
	for pkgix_prefix in "$@"; do
		export_env "$pkgix_prefix" || :
	done

	(( arg_debug )) && { show_platform_vars; } || :

	case "$PKGIX_SHELL" in
		*csh)
			[[ -n "${PKGIX_PREFIX:-}" ]] && echo "setenv PKGIX_PREFIX \"$PKGIX_PREFIX\"" || :
			[[ -n "${PATH:-}" ]] && echo "setenv PATH \"$PATH\"" || :
			[[ -n "${LD_RUN_PATH:-}" ]] && echo "setenv LD_RUN_PATH \"$LD_RUN_PATH\"" || :
			[[ -n "${LIBRARY_PATH:-}" ]] && echo "setenv LIBRARY_PATH \"$LIBRARY_PATH\"" || :
			[[ -n "${PKG_CONFIG_PATH:-}" ]] && echo "setenv PKG_CONFIG_PATH \"$PKG_CONFIG_PATH\"" || :
			[[ -n "${CPATH:-}" ]] && echo "setenv CPATH \"$CPATH\"" || :
			;;
		*)
			# Assume sh compatible shell (bash, zsh, ..)
			[[ -n "${PKGIX_PREFIX:-}" ]] && echo "export PKGIX_PREFIX=\"$PKGIX_PREFIX\"" || :
			[[ -n "${PATH:-}" ]] && echo "export PATH=\"$PATH\"" || :
			[[ -n "${LD_RUN_PATH:-}" ]] && echo "export LD_RUN_PATH=\"$LD_RUN_PATH\"" || :
			[[ -n "${LIBRARY_PATH:-}" ]] && echo "export LIBRARY_PATH=\"$LIBRARY_PATH\"" || :
			[[ -n "${PKG_CONFIG_PATH:-}" ]] && echo "export PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH\"" || :
			[[ -n "${CPATH:-}" ]] && echo "export CPATH=\"$CPATH\"" || :
			;;
	esac
} #}}}

#============================================================================
# is_pkg_pointer pkg_file
#
is_pkg_pointer() { #{{{
	[[ "$(wc -l < "$1")" =~ ^[^0-9]*[01][^0-9]*$ ]]
} #}}}

#============================================================================
# source_pkg_file pkg_file
#
source_pkg_file() { #{{{
	local pkg_name="$1"
	local pkg_file="$2"

	if is_pkg_pointer "$pkg_file"; then
		local resolved_pkg_name="$(<$pkg_file)"

		if [[ -z "${resolved_pkg_name:-}" ]]; then
			error_printf $"Empty package description file!\n"
			return $RET_ERR
		fi

		verbose_printf $"Pointer: %s -> %s\n" "$pkg_name" "$resolved_pkg_name"
		source_pkg "$resolved_pkg_name"
	else
		source "$pkg_file"
	fi
} #}}}

#============================================================================
# source_pkg pkg_name [prefer_repo]
#
source_pkg() { #{{{
	local pkg_name="$1"
	local prefer_repo="${2:-}"
	local pkg_file

	# Don't set repo as local here, as it can then be used in the package
	# description files to get information about its source repository, and 
	# e.g., download extra files such as patches from the repository.
	for repo in "$prefer_repo" "${PKGIX_REPOS[@]:+${PKGIX_REPOS[@]}}"; do
		[[ -z "$repo" ]] && continue || :
		pkg_file="${repo}/$pkg_name"

		case "$pkg_file" in
			http://*|https://*|ftp://*)
				local tmpfile="$(mktemp)"

				verbose_printf $"Trying: %s\n" "$pkg_file"
				if fetch_remote "$pkg_file" "$tmpfile" 2> /dev/null; then
					verbose_printf $"Source:"" ${Cgrn}%s${Crst}\n" "$pkg_file"
					source_pkg_file "$pkg_name" "$tmpfile"
					rm "$tmpfile"
					break
				fi
				rm "$tmpfile"
				;;
			*)
				verbose_printf $"Trying: %s\n" "$pkg_file"
				if [[ -f "$pkg_file" ]]; then
					verbose_printf $"Source:"" ${Cgrn}%s${Crst}\n" "$pkg_file"
					source_pkg_file "$pkg_name" "$pkg_file"
					break
				fi
				;;
		esac
	done

	[[ -n "${version:-}" || "${metapkg:-}" == "$METAPKG_DUMMY" ]]
} #}}}

#============================================================================
# sourced_pkg_call funcname [pkgix_prefix [install_dir]]
# Wrap sourced function call execution.
#
# Disable 'nounset' for calling sourced functions, as the complexity of package
# description files should be small enough to trade some code safety for
# convenience. Enable inside the functions if neccessary.
#
# Makes the following extra variables available to package description file:
#     prefix=pkgix_prefix
#     destdir=install_dir
#
# Otherwise potentially useful variables which are available from parent scope:
#     old_version - if package is being upgraded (see prefix_upgrade)
#     repo - the URL where the package description file is located
#
# Useful functions for use in package description files:
#     fetch, fetch_extract, die
#
# See platform detection above for variables identifying the host platform.
#
# Due to the way BASH behaves, propagating even local variables from a parent
# function to its children, ALL variables from parents will be available.
# However, as the function to be called is executed in a subshell, none of
# these variables can be affected after completion of sourced_pkg_call.
#
sourced_pkg_call() { #{{{
	local funcname=$1

	if ! type -p $funcname > /dev/null; then
		die $"Package file does not provide function: %s\n" "$funcname"
	fi

	(
		# Optional Arguments, passed as globals
		if [[ -n "${2:-}" ]]; then
			prefix="$2"
			[[ -n "${3:-}" ]] && destdir="$3"
		fi

		(( ! arg_debug )) && set +o nounset || :
		$funcname
	)
} #}}}

#============================================================================
# unset_sourced_pkg
# unsets all fields that could be set by a package file
#
unset_sourced_pkg() { #{{{
	unset metapkg
	unset satisfied
	unset version
	unset license
	unset website
	unset description
	unset depends
	unset iscompat
	unset isinstalled
	unset build
	unset installenv
	unset postinstall
	unset forceinstall
	unset backup
} #}}}

#============================================================================
# pkg_db_isinstalled pkgix_prefix pkg_name
#
pkg_db_isinstalled() { #{{{
	local pkgix_prefix="$1"
	local pkg_name="$2"
	local db_prefix="${pkgix_prefix}/${DB_PREFIX}/${pkg_name}"

	[[ -f "${db_prefix}/version" && -f "${db_prefix}/files" ]]
} #}}}

#============================================================================
# set_db_vars pkgix_prefix pkg_name
#
set_db_vars() { #{{{
	local pkgix_prefix="$1"
	local pkg_name="$2"
	db_prefix="${pkgix_prefix}/${DB_PREFIX}/${pkg_name}"
	db_files_file="${db_prefix}/files"
	db_backup_file="${db_prefix}/files.backup"
	db_version_file="${db_prefix}/version"
	db_info_file="${db_prefix}/info"
} #}}}

#============================================================================
# unset_db_vars
#
unset_db_vars() { #{{{
	unset db_prefix
	unset db_files_file
	unset db_backup_file
	unset db_version_file
	unset db_info_file
} #}}}

#============================================================================
# pkg_db_install pkgix_prefix pkg_name
#
pkg_db_install() { #{{{
	local pkgix_prefix="$1"
	local pkg_name="$2"
	local reason="$3"
	local staging_files_file="$4"
	local pkgnew_files_file="$5"
	local staging_backup_file="$6"

	set_db_vars "$pkgix_prefix" "$pkg_name"

	# Create installed database folders
	mkdir -p "${db_prefix}"

	# Use previously created list of files and pkgnew files
	cat "$staging_files_file" "$pkgnew_files_file" > "$db_files_file"
	rm "$staging_files_file" "$pkgnew_files_file"

	# Use previously created list of backup files
	mv "$staging_backup_file" "$db_backup_file"

	echo "${version:-}" > "$db_version_file"
	[[ -z "${version:-}" ]] && warning_printf $"Empty 'version' field in package description file of '%s'!\n" "$pkg_name"

	{
		echo "description=\"${description:-}\""
		echo "installdate=\"$(date)\""
		echo "website=\"${website:-}\""

		printf "license=("
		local license_elem
		for license_elem in "${license[@]:+${license[@]}}"; do
			printf " '%s'" "$license_elem"
		done
		printf " )\n"

		printf "depends=("
		local dep_name
		for dep_name in "${depends[@]:+${depends[@]}}"; do
			printf " '%s'" "$dep_name"
		done
		printf " )\n"

		echo "reason=\"${reason}\""
	} > "$db_info_file"

	[[ -z "${description:-}" ]] && warning_printf $"Empty 'description' field in package description file of '%s'!\n" "$pkg_name"
	[[ -z "${license[*]:+${license[*]}}" ]] && warning_printf $"Empty 'license' field in package description file of '%s'!\n" "$pkg_name"
	[[ -z "${website:-}" ]] && warning_printf $"Empty 'website' field in package description file of '%s'!\n" "$pkg_name"

	# The db file is important for upgrading packages in the order they were installed!
	# As the entries are not deleted upon removal, over time, a dependence ordering
	# is being built, so that if removed packages are reinstalled, upgrading still
	# works as before.
	local db_file="${pkgix_prefix}/${DB_PREFIX}.db"

	if [[ -f "$db_file" ]] && grep -q "^.|${pkg_name}$" "$db_file"; then
		sed -i "s:^.|${pkg_name}$:i|${pkg_name}:" "$db_file"
	else
		echo "i|$pkg_name" >> "$db_file"
	fi

	unset_db_vars
} #}}}

#============================================================================
# unset_db_info
#
unset_db_info() { #{{{
	unset description
	unset website
	unset license
	unset depends
	unset installdate
	unset reason
} #}}}

#============================================================================
# pkg_db_info_query pkgix_prefix pkg_name property [default]
#
# Only use this function to query a single property, as it would be inefficient
# for querying multiple properties in sequence; for this source the db_info_file
# and subsequently call unset_db_info.
#
# Only echos the property as a string, and should not be used if the property
# type is an array.
#
pkg_db_info_query() { #{{{
	local pkgix_prefix="$1"
	local pkg_name="$2"
	local property="$3"
	local default="${4:-}"

	(
		local result

		set_db_vars "$pkgix_prefix" "$pkg_name"

		case "$property" in
			version)
				result="$(<"$db_version_file")"
				[[ -z "$result" ]] && echo "$default" || echo "$result"
				;;
			*)
				source "$db_info_file"
				echo "${!property:-${default}}"
				unset_db_info
				;;
		esac

		unset_db_vars
	)
} #}}}

#============================================================================
# db_list_installed
#
db_list_installed() { #{{{
	local pkgix_prefix="$1"

	if [[ -f "${pkgix_prefix}/${DB_PREFIX}.db" ]]; then
		local pkg_name
		grep "^i|" "${pkgix_prefix}/${DB_PREFIX}.db" |
		while read pkg_name; do
			pkg_name="${pkg_name##i|}"
			if ! pkg_db_isinstalled "$pkgix_prefix" "$pkg_name"; then
				warning_printf $"Inconsistent database entry: %s\n" "$pkg_name"
				continue
			fi

			echo "$pkg_name"
		done
	fi
} #}}}

#============================================================================
# pkg_install pkgix_prefix pkg_name [reinstall [reason]]
#
pkg_install() { #{{{
	local pkgix_prefix="$1"
	local pkg_name="$2"
	local reinstall="${3:-0}"
	local reason="${4:-$REASON_EXPLICIT}"
	local is_reinstall=0

	if [[ ! -d "$pkgix_prefix" ]]; then
		die $"'%s' is not a valid directory!\n" "$pkgix_prefix"
	fi

	if pkg_db_isinstalled "$pkgix_prefix" "$pkg_name"; then
		if (( ! reinstall )); then
			local _fn_printf
			[[ "$reason" == "$REASON_EXPLICIT" ]] && _fn_printf="msg_printf" || _fn_printf="verbose_printf"
			$_fn_printf "${Cgrn}%s${Crst} "$"is available\n" "$pkg_name"
			return $RET_OK
		else
			is_reinstall=1

			# Set reason based on user-override if provided, otherwise preserve previous reason
			if (( ! arg_reason_dependency && ! arg_reason_explicit )); then
				reason="$(pkg_db_info_query "$pkgix_prefix" "$pkg_name" "reason" "$reason")"
			fi
		fi
	fi

	# Only allow forcing reason for explicitly selected packages.
	if [[ "$reason" == "$REASON_EXPLICIT" ]]; then
		if (( arg_reason_dependency )); then
			reason="$REASON_DEPENDENCY"
		elif (( arg_reason_explicit )); then
			reason="$REASON_EXPLICIT"
		fi
	fi

	msg_printf "${CcynB}=> %s${Crst}\n" "$pkg_name"

	(
		export_env "$pkgix_prefix" 1

		# Source package description file and try to traverse until a non-meta
		# package description is found.
		local next_pkg_name="$pkg_name" # preserve requested package name
		while :; do
			# Unset previous package variables, otherwise we might end in an
			# endless loop when resolving dependencies, metapkgs, or might even
			# keep unset variables/functions.
			unset_sourced_pkg

			if ! source_pkg "$next_pkg_name"; then
				die $"Could not find valid package description file for '%s'!\n" "$next_pkg_name"
			fi

			# Not a meta-package, continue normally
			[[ -z "${metapkg:-}" ]] && break

			# Is metapackage, check if satisfied
			if (( ! is_reinstall )) && sourced_pkg_call satisfied; then
				if (( ! arg_force )); then
					msg_printf $"Metapackage '%s' satisfied.\n" "$next_pkg_name"
					exit $EXIT_OK
				else
					warning_printf $"Forcing installation of metapackage '%s', despite satisfied...\n" "$next_pkg_name"
				fi
			fi

			# If this metapackage is only a dummy to check if a dependence is satisfied,
			# and the above 'satisfied' function failed, this is a dead end.
			if [[ "$metapkg" == "$METAPKG_DUMMY" ]]; then
				die $"Metapackage '%s' could not be satisfied!\n" "$next_pkg_name"
			fi

			# Not satisfied and not a dummy, resolve this by trying to install
			# the suggested package metapkg.
			msg_printf $"Metapackage: %s -> %s\n" "$next_pkg_name" "$metapkg"
			next_pkg_name="$metapkg"
		done

		if (( ! is_reinstall )) && sourced_pkg_call isinstalled; then
			if (( ! arg_force )); then
				msg_printf $"'%s' already available outside of '%s', skipping...\n" "$pkg_name" "$pkgix_prefix"
				exit $EXIT_OK
			else
				msg_printf $"Forcing installation of '%s', despite already available outside of '%s'...\n" "$pkg_name" "$pkgix_prefix"
			fi
		fi

		if ! sourced_pkg_call iscompat; then
			if (( ! arg_force )); then
				die $"'%s' is not compatible with your system!\n" "$pkg_name"
			else
				warning_printf $"Trying installation of '%s', despite system incompatibility...\n" "$pkg_name"
			fi
		fi

		if (( ! arg_nodeps )); then
			msg_printf "${Cgrn}%s (%s)${Crst} "$"resolving dependencies...\n" "$pkg_name" "${version:-}"
			local dep_name
			for dep_name in "${depends[@]:+${depends[@]}}"; do
				pkg_install "$pkgix_prefix" "$dep_name" 0 "$REASON_DEPENDENCY"
			done
		else
			warning_printf $"Ignoring dependencies.\n"
		fi

		if (( arg_dry_run )); then
			msg_printf "${CgrnB}%s (%s)${Crst} "$"dry install complete.\n" "$pkg_name" "${version:-}"
			exit $EXIT_OK
		fi

		# Reset and set environment again after installing dependencies, so
		# that the environment variables capture all folders that may have been
		# installed by the dependencies.
		export_env "$pkgix_prefix" 1

		msg_printf "${Cgrn}%s (%s)${Crst} "$"building...\n" "$pkg_name" "${version:-}"

		local build_dir
		local install_dir
		if [[ -n "${PKGIX_BUILD_DIR:-}" ]]; then
			build_dir="${PKGIX_BUILD_DIR}/${PROGNAME}-build"
			install_dir="${PKGIX_BUILD_DIR}/${PROGNAME}-install"
		else
			build_dir="${pkgix_prefix}/.${PROGNAME}-build"
			install_dir="${pkgix_prefix}/.${PROGNAME}-install"
		fi

		mkdir -p "$build_dir"
		mkdir -p "$install_dir"

		pushd "$build_dir" &> /dev/null

		# Setup cleanup trap, as this is executed in subshell, it does not
		# affect the parent shell's trap which will be executed normally on exit.
		local trap_cmd="{ popd &> /dev/null; rm -rf \"$install_dir\";"
		(( ! arg_keep_build_dir )) && trap_cmd+=" rm -rf \"$build_dir\";"
		trap_cmd+=" }"

		trap "$trap_cmd" EXIT

		if ! sourced_pkg_call build "$pkgix_prefix" "$install_dir"; then
			die $"Building '%s' failed! Aborting.\n" "$pkg_name"
		fi

		msg_printf "${Cgrn}%s (%s)${Crst} "$"installing into staging area...\n" "$pkg_name" "${version:-}"

		if ! sourced_pkg_call installenv "$pkgix_prefix" "$install_dir"; then
			die $"Installation of '%s' failed! Aborting.\n" "$pkg_name"
		fi

		if (( is_reinstall )); then
			# Remove after build/installenv, so that if building/installing
			# a package depends on itself it is used rather than the system
			# version (e.g., gcc, make).  If the system version should be used
			# again: remove->install manually.
			pkg_remove "$pkgix_prefix" "$pkg_name"
		fi

		# Create the list of files to be installed
		local staging_files_file="${build_dir}/.staging.files"
		: > "$staging_files_file"
		if [[ -d "${install_dir}/${pkgix_prefix}" ]]; then
			# As prefix is $pkgix_prefix, the complete folder structure from / is maintained inside $install_dir
			find_printbase "${install_dir}/${pkgix_prefix}" > "$staging_files_file"
		else
			warning_printf $"Package did not install any files.\n"
		fi

		# Require files.backup file; can be empty.
		# Perform this step before moving files to .pkgnew!
		local staging_backup_file="${build_dir}/.staging.files.backup"
		: > "$staging_backup_file"
		local backup_path
		local backup_checksum_sha256
		for backup_path in "${backup[@]:+${backup[@]}}"; do
			# Only do checksum based backup with real files
			if [[ -f "${install_dir}/${pkgix_prefix}/${backup_path}" ]]; then
				backup_checksum_sha256=($(sha256checksum "${install_dir}/${pkgix_prefix}/${backup_path}"))
				backup_checksum_sha256="${backup_checksum_sha256[0]}"
			else
				backup_checksum_sha256=""
			fi

			echo "${backup_path}:${backup_checksum_sha256}" >> "$staging_backup_file"
		done

		# Check for file conflicts before copying from install_dir to pkgix_prefix
		local pkgnew_files_file="${build_dir}/.pkgnew.files"
		: > "$pkgnew_files_file"
		if (( ! arg_force )); then
			msg_printf "${Cgrn}%s (%s)${Crst} "$"checking for file conflicts...\n" "$pkg_name" "${version:-}"

			while read path; do
				if [[ ! -d "${pkgix_prefix}/${path}" && -e "${pkgix_prefix}/${path}" ]]; then
					in_list "$path" "${forceinstall[@]:+${forceinstall[@]}}" && continue || :

					# Only if the file already exists in pkgix_prefix and in
					# the backup list, should it be installed as a .pkgnew file.
					if in_list "$path" "${backup[@]:+${backup[@]}}"; then
						mv "${install_dir}/${pkgix_prefix}/${path}" "${install_dir}/${pkgix_prefix}/${path}.pkgnew"
						echo "${path}.pkgnew" >> "$pkgnew_files_file"
						warning_printf $"Installing '%s' as '%s'\n" "$path" "${path}.pkgnew"
						continue
					fi

					die $"Conflict detected: %s\n" "$path"
				fi
			done < "$staging_files_file"
		else
			warning_printf $"Skipping file conflict check.\n"
		fi

		msg_printf "${Cgrn}%s (%s)${Crst} "$"installing...\n" "$pkg_name" "${version:-}"

		# Perform actual installation
		if [[ -d "${install_dir}/${pkgix_prefix}" ]]; then
			cp -a "${install_dir}/${pkgix_prefix}"/* "${pkgix_prefix}"
		fi

		pkg_db_install "$pkgix_prefix" "$pkg_name" "$reason" \
			"$staging_files_file" "$pkgnew_files_file" "$staging_backup_file"

		trap - EXIT
		popd &> /dev/null
		(( ! arg_keep_build_dir )) && rm -rf "$build_dir"
		rm -rf "$install_dir"

		# Run postinstall if available
		if type -p postinstall > /dev/null; then
			msg_printf "${Cgrn}%s (%s)${Crst} "$"post-install...\n" "$pkg_name" "${version:-}"
			if ! sourced_pkg_call postinstall "$pkgix_prefix"; then
				warning_printf $"Post-installation step failed!\n"
			fi
		fi

		msg_printf "${CgrnB}%s (%s)${Crst} "$"successfully installed.\n" "$pkg_name" "${version:-}"
		log_printf "$pkgix_prefix" "%s (%s) "$"installed\n" "$pkg_name" "${version:-}"
	) || exit $?

	return $RET_OK
} #}}}

#============================================================================
# pkg_remove pkgix_prefix pkg_name
#
pkg_remove() { #{{{
	local pkgix_prefix="$1"
	local pkg_name="$2"
	local purge="${3:-0}"

	if ! pkg_db_isinstalled "$pkgix_prefix" "$pkg_name"; then
		die $"'%s' not found!\n" "$pkg_name"
	fi

	set_db_vars "$pkgix_prefix" "$pkg_name"
	local version="$(<"$db_version_file")"

	# Create an empty files.backup file if it does not exist [backwards compatibility].
	if (( purge )) || [[ ! -f "$db_backup_file" ]]; then
		: > "$db_backup_file"
	fi

	msg_printf "${Cgrn}%s (%s)${Crst} "$"removing...\n" "$pkg_name" "$version"

	local backup_path
	local backup_checksum_sha256
	local backup_checksum_sha256_f
	while read backup_path; do
		# (0) Check for changed files which require backup
		backup_checksum_sha256="${backup_path##*:}"
		backup_path="${backup_path%:*}"

		if [[ -f "${pkgix_prefix}/${backup_path}" ]]; then
			backup_checksum_sha256_f=($(sha256checksum "${pkgix_prefix}/${backup_path}"))
			backup_checksum_sha256_f="${backup_checksum_sha256_f[0]}"

			# If file changed, exclude from deletion
			if [[ "$backup_checksum_sha256" != "$backup_checksum_sha256_f" ]]; then
				verbose_printf $"Keeping modified '%s'\n" "$backup_path"
				echo "^${backup_path}$"
			fi
		else
			# Exclude by default
			echo "^${backup_path}$"
		fi
	done < "$db_backup_file" | grep -v -f - "$db_files_file" |
	while read filename; do
		# (1) First pass delete files and get directory depths

		if [[ ! -d "${pkgix_prefix}/$filename" ]]; then
			rm -f "${pkgix_prefix}/$filename"
		else
			# Get path depth for sorting: If we don't do this, directories
			# which are higher up in the hierarchy are being tried to be
			# deleted before its subdirectories, which could be empty, but
			# because the subdirectories still exist, the parent won't be
			# deleted.
			local o_IFS="$IFS"         ; IFS="/"
			local tmp=(${filename[@]}) ; IFS="$o_IFS"
			printf "${#tmp[@]}:${filename}\n"
		fi
	done | sort -rn |
	while read filename; do
		# (2) Then check for empty directories and delete if empty
		local filename="${filename#*:}"
		remove_empty_dirs "${pkgix_prefix}/$filename" 0
	done

	# Remove meta files
	rm "$db_files_file"
	rm "$db_backup_file"
	rm "$db_version_file"
	rm "$db_info_file"

	# Clean up db
	remove_empty_dirs "${pkgix_prefix}/${DB_PREFIX}"

	# Set package as removed
	sed -i "s:^.|${pkg_name}$:r|${pkg_name}:" "${pkgix_prefix}/${DB_PREFIX}.db"

	msg_printf "${CgrnB}%s (%s)${Crst} "$"successfully removed.\n" "$pkg_name" "$version"
	log_printf "$pkgix_prefix" "%s (%s) "$"removed\n" "$pkg_name" "$version"

	unset_db_vars
} #}}}

#============================================================================
# cmd_install pkgix_prefix pkg_name...
#
cmd_install() { #{{{
	local pkgix_prefix="$(abspath "$1")"
	shift

	if [[ -z "${1:-}" ]]; then
		die $"You need to specify at least one package to install.\n"
	fi

	if [[ ! -d "${pkgix_prefix}" ]]; then
		if ! mkdir -p "${pkgix_prefix}" 2> /dev/null; then
			die $"Could not create directory '%s'!\n" "$pkgix_prefix"
		fi

		# dir exists now, normalize path just in case it contained `..`s
		pkgix_prefix="$(abspath "$pkgix_prefix")"
	fi

	lock_prefix "$pkgix_prefix" || exit $EXIT_ERR

	msg_printf $"Installing into %s: %s\n" "$pkgix_prefix" "$*"
	prompt_continue || exit $EXIT_USER_ABORT

	local pkg_name
	for pkg_name in "$@"; do
		pkg_install "$pkgix_prefix" "$pkg_name" "$arg_reinstall"
	done

	unlock_prefix "$pkgix_prefix"
} #}}}

#============================================================================
# prefix_upgrade pkgix_prefix
#
prefix_upgrade() { #{{{
	local pkgix_prefix="$(abspath "$1")"
	shift

	if [[ ! -f "${pkgix_prefix}/${DB_PREFIX}.db" ]]; then
		warning_printf $"'%s' is not a valid prefix!\n" "$pkgix_prefix"
		return $RET_INVALID_OPTION
	fi

	lock_prefix "$pkgix_prefix" || exit $EXIT_ERR

	msg_printf $"Upgrading %s ...\n" "$pkgix_prefix"
	prompt_continue || return $RET_USER_ABORT

	db_list_installed "$pkgix_prefix" |
	while read pkg_name; do
		# If package list provided, filter by that list
		if (( $# > 0 )); then
			in_list "$pkg_name" "$@" || continue
		fi

		(
			old_version="$(pkg_db_info_query "$pkgix_prefix" "$pkg_name" "version")"

			# Source prefix RC-file, so that we could use PKGIX_REPOS from this
			# RC-file in source_pkg, if set. Similiarly for PKGIX_UPGRADE_IGNORE.
			source_prefix_rc "$pkgix_prefix"

			if ! source_pkg "$pkg_name"; then
				warning_printf $"Could not find package description file for '%s', skipping upgrade...\n" "$pkg_name"
			elif [[ "${version:-}" != "$old_version" ]] || (( arg_reinstall )); then
				if in_list "$pkg_name" "${PKGIX_UPGRADE_IGNORE[@]:+${PKGIX_UPGRADE_IGNORE[@]}}"; then
					msg_printf "${Cylw}"$"Skipping upgrade""${Crst} %s (%s -> %s)\n" "$pkg_name" "$old_version" "${version:-}"
				else
					msg_printf "${Ccyn}"$"Upgrading""${Crst} %s (%s -> %s)" "$pkg_name" "$old_version" "${version:-}"
					(( ! arg_reinstall )) && printf "\n" || printf " - "$"reinstall\n"
					log_printf "$pkgix_prefix" $"upgrading"" %s (%s -> %s)\n" "$pkg_name" "$old_version" "${version:-}"

					pkg_install "$pkgix_prefix" "$pkg_name" 1
				fi
			else
				msg_printf "%s (%s) "$"is up to date\n" "$pkg_name" "$old_version"
			fi
		) || exit $?  # Break out of pipe-subshell
	done || return $? # Take return code if pipe-subshell exited with errors

	msg_printf $"Done upgrading.\n"

	unlock_prefix "$pkgix_prefix"
} #}}}

#============================================================================
# cmd_upgrade pkgix_prefix...
#
cmd_upgrade() { #{{{
	local pkgix_prefixes=()
	while [[ -n "${1:-}" && "$1" != "--" ]]; do
		pkgix_prefixes+=("$1")
		shift || break
	done
	shift || :

	local pkgix_prefix
	local ret_code
	for pkgix_prefix in "${pkgix_prefixes[@]}"; do
		# Run nested, not to pollute subsequent upgrades with export_env
		# The environment should be set accordingly prior to upgrading!
		( prefix_upgrade "$pkgix_prefix" "$@" ) && ret_code=$? || ret_code=$?
		if (( ret_code != RET_OK && ret_code != RET_INVALID_OPTION && ret_code != RET_USER_ABORT )); then
			exit $EXIT_ERR
		fi
	done
} #}}}

#============================================================================
# cmd_remove pkgix_prefix pkg_name...
#
cmd_remove() { #{{{
	local pkgix_prefix="$(abspath "$1")"
	shift || die $"No targets specified!\n"

	if [[ ! -d "$pkgix_prefix" ]]; then
		die $"'%s' is not a valid directory!\n" "$pkgix_prefix"
	fi

	lock_prefix "$pkgix_prefix" || exit $EXIT_ERR

	msg_printf $"Removing from %s: %s\n" "$pkgix_prefix" "$*"
	prompt_continue || exit $EXIT_USER_ABORT
	
	local pkg_name
	for pkg_name in "$@"; do
		pkg_remove "$pkgix_prefix" "$pkg_name" "$arg_purge"
	done

	unlock_prefix "$pkgix_prefix"
} #}}}

#============================================================================
# cmd_avail
#
cmd_avail() { #{{{
	if (( $# == 0 )); then
		local repo
		for repo in "${PKGIX_REPOS[@]:+${PKGIX_REPOS[@]}}"; do
			(( ! arg_quiet )) && printf "%b" "${CbluB}-> ${CgrnB}${repo}${Crst}\n" 1>&2 || :
			case "$repo" in
				http://*|https://*|ftp://*)
					(
						if ! fetch_remote "${repo}/$REMOTE_AVAIL_FILE" "-" 2> /dev/null; then
							warning_printf $"Fetching '%s' failed!\n" "${repo}/$REMOTE_AVAIL_FILE"
						fi
					) |
					while read pkg_short_info; do
						if (( arg_quiet )); then
							echo "$repo ${pkg_short_info%% *}"
						else
							echo "$pkg_short_info"
						fi
					done
					;;
				*)
					# Do not show hidden files and do not descend into hidden folders.
					# Need trailing slash, in case the repo is the path to a symlink.
					find_printbase "${repo}/" ! \( -name ".*" -prune \) -a \( -type f \) 2> /dev/null | sort |
					while read pkg_name; do
						if (( arg_quiet )); then
							echo "$repo $pkg_name"
						else
							if is_pkg_pointer "${repo}/$pkg_name"; then
								printf "%-42s %-18s %s\n" "$pkg_name" "->" "$(<"${repo}/$pkg_name")"
							else
								(
									source "${repo}/$pkg_name"
									printf "%-42s %-18s %s\n" "$pkg_name" "${version:-}" "${description:-}"
								)
							fi
						fi
					done
					;;
			esac
		done
	else
		local pkg_name
		for pkg_name in "$@"; do
			(
				if source_pkg "$pkg_name"; then
					echo "$pkg_name (${version:-}): ${repo}"
					echo " Description  : ${description:-}"
					if [[ -z "${metapkg:-}" ]]; then
						echo " Website      : ${website:-}"
						echo " License      : ${license[*]:+${license[*]}}"
						echo " Depends      : ${depends[*]:+${depends[*]}}"
					else
						if [[ "$metapkg" != "$METAPKG_DUMMY" ]]; then
							echo " Metapackage -> $metapkg"
						fi
					fi
				else
					msg_printf $"'%s' not found!\n" "$pkg_name"
				fi

				echo
			)
		done
	fi
} #}}}

#============================================================================
# cmd_list pkgix_prefix...
#
cmd_list() { #{{{
	local pkgix_prefix
	for pkgix_prefix in "$@"; do
		[[ -d "$pkgix_prefix" ]] || continue && pkgix_prefix="$(abspath "$pkgix_prefix")"
		(( ! arg_quiet )) && printf "%b" "${CbluB}-> ${CgrnB}${pkgix_prefix}${Crst}\n" 1>&2 || :

		db_list_installed "$pkgix_prefix" | sort |
		while read pkg_name; do
			(
				set_db_vars "$pkgix_prefix" "$pkg_name"

				if (( ! arg_quiet || arg_list_explicit || arg_list_depends || arg_list_unrequired )); then
					source "$db_info_file"
				fi

				if (( arg_list_explicit && ! arg_list_depends )); then
					[[ "${reason:-}" != "$REASON_EXPLICIT" ]] && continue || :
				fi

				if (( ! arg_list_explicit && arg_list_depends )); then
					[[ "${reason:-}" != "$REASON_DEPENDENCY" ]] && continue || :
				fi

				if (( arg_list_unrequired )); then
					(
						# Check if any package in any provided pkgix_prefix
						# depends on the current package; if the current
						# package is required, continue while loop.

						for _pkgix_prefix in "$@"; do
							[[ -d "$_pkgix_prefix" ]] || continue && _pkgix_prefix="$(abspath "$_pkgix_prefix")"
							db_list_installed "$_pkgix_prefix" |
							while read _pkg_name; do
								set_db_vars "$_pkgix_prefix" "$_pkg_name"

								# Tried using grep here, but the BASH-only
								# version is roughly 2x faster.
								source "$db_info_file"
								if in_list "$pkg_name" "${depends[@]:+${depends[@]}}"; then
									verbose_printf $"'%s: %s' required by '%s: %s'\n" "$pkgix_prefix" "$pkg_name" "$_pkgix_prefix" "$_pkg_name"
									exit $EXIT_ERR
								fi
							done || exit $?
						done
					) || continue
				fi

				if (( arg_quiet )); then
					echo "$pkgix_prefix $pkg_name"
				else
					printf "%-42s %-18s %s\n" "${pkg_name}" "$(<$db_version_file)" "${description:-}"
				fi
			)
		done
	done
} #}}}

#============================================================================
# cmd_show pkgix_prefix pkg_name...
#
cmd_show() { #{{{
	local pkgix_prefixes=()

	if in_list "--" "$@"; then
		while [[ "$1" != "--" ]]; do
			pkgix_prefixes+=("$1")
			shift || break
		done
	else
		pkgix_prefixes+=("${1:-}")
	fi

	shift || die $"No targets specified!\n"

	local pkg_name
	local pkgix_prefix
	for pkg_name in "$@"; do
		for pkgix_prefix in "${pkgix_prefixes[@]}"; do
			pkgix_prefix="$(abspath "$pkgix_prefix")"
			if [[ ! -d "$pkgix_prefix" ]]; then
				die $"'%s' is not a valid directory!\n" "$pkgix_prefix"
			fi

			set_db_vars "$pkgix_prefix" "$pkg_name"

			if pkg_db_isinstalled "$pkgix_prefix" "$pkg_name"; then
				if (( arg_list_files )); then
					local prefix_line=""
					(( ! arg_quiet )) && prefix_line="$pkg_name " || :
					local path
					while read path; do
						[[ -n "$path" ]] && echo "${prefix_line}${pkgix_prefix}/${path}" || :
					done < "$db_files_file"
				else
					source "$db_info_file"
					echo "$pkg_name ($(<$db_version_file)): ${pkgix_prefix}"
					echo " Description  : ${description:-}"
					echo " Website      : ${website:-}"
					echo " License      : ${license[*]:+${license[*]}}"
					echo " Depends      : ${depends[*]:+${depends[*]}}"
					echo " Install date : ${installdate:-}"
					echo " Reason       : ${reason:-}"

					echo
					unset_db_info
				fi

				# found, stop searching further pkgix_prefixes
				break
			else
				# indicate not yet found, continue search
				db_prefix=""
			fi
		done

		if [[ -z "$db_prefix" ]]; then
			die $"'%s' not found!\n" "$pkg_name"
		fi

		unset_db_vars
	done
} #}}}

#============================================================================
# cmd_chenv pkgix_prefix...
#
cmd_chenv() { #{{{
	local pkgix_prefix
	for pkgix_prefix in "$@"; do
		export_env "$pkgix_prefix"
	done

	msg_printf $"Spawning shell\n"
	exec "$PKGIX_SHELL"
} #}}}

#============================================================================
# sanitize_repos
# Turn PKGIX_REPOS into an array and sanitize some URLs
#
sanitize_repos() { #{{{
	# Check if it is already an array (user set in RC-file)
	if [[ "$(declare -p PKGIX_REPOS)" =~ ^"declare -a" ]]; then
		local old_repos=("${PKGIX_REPOS[@]:+${PKGIX_REPOS[@]}}")
	else
		local o_IFS="$IFS" ; IFS="$URL_SEP"
		local old_repos=(${PKGIX_REPOS[@]})
		IFS="$o_IFS" ; unset o_IFS
	fi

	PKGIX_REPOS=()

	local repo
	for repo in "${old_repos[@]:+${old_repos[@]}}"; do
		[[ "$repo" =~ ^file:// ]] && repo="${repo##file://}"
		repo=${repo%%/}

		PKGIX_REPOS+=("${repo}")
	done
} #}}}

#============================================================================
# prog_usage
# Use *spaces* to indent printed text!!
#
prog_usage() { #{{{
	if [[ -z "${1:-}" ]]; then
		printf -- $"Usage: %s [-r|--repo <repo>] [-n|--noconfirm]\n\
             [-v|--verbose] [--debug]\n\
             <command> [<args>]\n" "$PROGNAME"
		echo
		printf -- $"Commands available:\n"
		printf -- $"    install    Install a package in a prefix environment\n"
		printf -- $"    remove     Remove an installed package\n"
		printf -- $"    upgrade    Upgrade a prefix environment\n"
		printf -- $"    avail      List packages available to install\n"
		printf -- $"    list       List installed packages\n"
		printf -- $"    show       Show information about installed packages\n"
		printf -- $"    showenv    Show prefix environment parameters\n"
		printf -- $"    chenv      Switch to a prefix environment\n"
		echo
		printf -- $"Options:\n"
		printf -- $"\
    -r, --repo\n\
        Specify additional package repository URLs; use '%s' to\n\
        separate multiple repositories. Currently supported protocols are:\n\
        file:// (default), http://, https://, ftp://\n" "$URL_SEP"
		printf -- $"\
    -n, --noconfirm\n\
        Proceed without asking the user for confirmation.\n"
		printf -- $"\
    -v, --verbose\n\
        Be more verbose.\n"
		printf -- $"\
    -q, --quiet\n\
        Be less verbose; some commands can show less information,\n\
        which makes their output more easily parsable by other tools.\n"
		printf -- $"\
    -d, --debug\n\
        Debug mode: enable nounset for package files\n"
		printf -- $"\
    -h, --help\n\
        Display this help message.\n"
		printf -- $"\
    -V, --version\n\
        Display version information.\n"
		echo
		printf -- $"See '%s help <command>' for more information on a command.\n" "$PROGNAME"
	else
		case "${1:-}" in
			install|upgrade)
				printf -- $"Usage: %s %s [-f|--force] [-d|--nodeps] [-r|--reinstall]\n\
                     [-k|--keep-build-dir] [--ignore-checksums]\n\
                     [--asdeps] [--asexplicit]\n" "$PROGNAME" "$1"

				if [[ "$1" == "install" ]]; then
					printf -- $"                     <prefix> <pkgs>...\n"
				else
					printf -- $"                     <prefixes>... [-- <pkgs>...]\n"
				fi

				echo
				printf -- $"Options:\n"
				printf -- $"\
    -f, --force\n\
        Force installation of programs that are: already available outside of\n\
        <prefixes>; satisfied metapackages; incompatible with the current system;\n\
        conflicting with already installed files.\n\
        Also forces overwriting files which were normally preserved (see backup).\n"
				printf -- $"\
    -d, --nodeps\n\
        Ignore dependenciy check and do not install dependencies.\n"
				printf -- $"\
    -r, --reinstall\n\
        Reinstall non-dependency, explicitly selected packages. When upgrading,\n\
        reinstall all installed packages.\n"
				printf -- $"\
    -k, --keep-build-dir\n\
        Keeps the build directory.\n"
				printf -- $"\
    -D, --dry\n\
        Dry run only; do not install or upgrade anything.\n\
        Useful to show what would be installed, including dependencies.\n"
				printf -- $"\
    --ignore-checksums\n\
        Ignores checksums for remotely fetched files.\n"
				printf -- $"\
    --asdeps\n\
        Set reason for all selected packages to installed as a dependency.\n"
				printf -- $"\
    --asexplicit\n\
        Set reason for all selected packages to explicitly installed.\n"
				;;
			remove)
				printf -- $"Usage: %s %s [-P|--purge]\n" "$PROGNAME" "$1"
				echo
				printf -- $"Options:\n"
				printf -- $"\
    -P, --purge\n\
        Force removal of all installed files, even those marked for backup.\n"
				;;
			show)
				printf -- $"Usage: %s %s [-l|--list] (<prefixes>... --|<prefix>) <pkgs>...\n" "$PROGNAME" "$1"
				echo
				printf -- $"Options:\n"
				printf -- $"\
    -l, --list\n\
        List installed package files.\n"
				;;
			list)
				printf -- $"Usage: %s %s [-e|--explicit] [-d|--depends] [-u|--unrequired] <prefixes>...\n" "$PROGNAME" "$1"
				echo
				printf -- $"Options:\n"
				printf -- $"\
    -e, --explicit\n\
        List only explicitly installed packages.\n"
				printf -- $"\
    -d, --depends\n\
        List only packages installed as a dependency for another package.\n"
				printf -- $"\
    -u, --unrequired\n\
        List unrequired packages: packages not required by any other package;\n\
        checks dependencies between all listed <prefixes>.\n"
				;;
			showenv|chenv)
				printf -- $"Usage: %s %s <prefixes>...\n" "$PROGNAME" "$1"
				;;
			avail)
				printf -- $"Usage: %s %s [<pkgs>...]\n" "$PROGNAME" "$1"
				echo
				printf -- $"\
If a list of <pkgs> is provided, displays detailed information about the\n\
packages found; otherwise, a short list of all packages in available\n\
repositories is displayed.\n"
				;;
			help)
				printf -- $"Usage: %s %s <command>\n" "$PROGNAME" "$1"
				;;
			*)
				printf -- $"Please specify valid command.\n"
				exit $EXIT_INVALID_OPTION
				;;
		esac
	fi
} #}}}

#============================================================================
# prog_version
#
prog_version() { #{{{
	echo "$PROGNAME $PROG_VERSION"
	echo
	echo "Copyright (C) 2012, Marco Elver <me@marcoelver.com>"
	echo
	echo "This is free software; see the source for copying conditions."
	echo "There is NO WARRANTY, to the extent permitted by law."
} #}}}

#============================================================================
# trap_ERR errcode lineno command [traceback...]
#
trap_ERR() { #{{{
	local errcode="$1"
	local lineno="$2"
	local command="$3"
	shift 3
	local traceback=""

	[[ -n "$*" ]] && printf -v traceback "\n    ${CredB}=>${Crst} in %s" "$@"
	error_printf "line %s - '%s' failed (code=%s)%s\n" "$lineno" "$command" "$errcode" "$traceback"
	exit 42
} #}}}

#============================================================================
# reset_traps
# Initializes traps
#
reset_traps() { #{{{
	trap '{ msg_printf $"TERM signal caught, exiting...\n"; exit 42; }' TERM HUP QUIT
	trap '{ msg_printf $"User aborted.\n"; exit 42; }' INT
	trap 'trap_ERR "$?" "$LINENO" "$BASH_COMMAND" "${FUNCNAME[@]:+${FUNCNAME[@]}}"' ERR
} #}}}

#============================================================================
# expand_short_opts opts arg
# Sets global array expanded_short_opts
#
# Rewrites a block of short options into an array, which can then be used
# to replace the current positional arguments with the expanded version
# so that they can be parsed normally, while still allowing GNU-style
# long options below.
#
expand_short_opts() { #{{{
	OPTIND=1
	expanded_short_opts=()

	local opts="$1"
	local arg="$2"

	local opt
	while getopts ":${opts}" opt "$arg"; do
		case "$opt" in
			:|\?)
				prog_usage "${cmd:-}"
				exit $EXIT_INVALID_OPTION
				;;
			*) expanded_short_opts+=("-$opt") ;;
		esac
	done
} #}}}

#============================================================================
# run_cmd
# command wrapper
#
run_cmd() { #{{{
	case "$cmd" in
		install|remove)
			if [[ -z "${PKGIX_PREFIX:-}" ]]; then
				if [[ -z "${1:-}" ]]; then
					die $"You need to specify a prefix!\n"
				fi

				cmd_$cmd "$@"
			else
				# Commands which can only accept one prefix, pass first one only
				# Remove leading ':'
				local args_prefix="${PKGIX_PREFIX##:}"
				cmd_$cmd "${args_prefix%%:*}" "$@"
			fi
			;;
		upgrade|list|show|showenv|chenv)
			if [[ -z "${PKGIX_PREFIX:-}" ]]; then
				case "$cmd" in
					# List of commands which are useful without a prefix
					showenv|chenv) ;;
					*)
						if [[ -z "${1:-}" ]]; then
							die $"You need to specify at least one prefix!\n"
						fi
						;;
				esac

				cmd_$cmd "$@"
			else
				local o_IFS="$IFS" ; IFS=":"
				local args_prefix=(${PKGIX_PREFIX[@]})
				IFS="$o_IFS" ; unset o_IFS

				case "$cmd" in
					show|upgrade) cmd_$cmd "${args_prefix[@]}" -- "$@" ;;
					*) cmd_$cmd "${args_prefix[@]}" "$@" ;;
				esac
			fi
			;;
		avail)
			cmd_$cmd "$@"
			;;
		*)
			die $"Unknown command: %s\n" "$cmd"
			;;
	esac
} #}}}

#============================================================================
# MAIN
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# {{{

reset_traps

#============================================================================
# Get global options
#
arg_verbose=0
arg_quiet=0
arg_noconfirm=0
arg_debug=0

while :; do
	case "${1:-}" in
		-r|--repo)
			[[ -z "${2:-}" ]] && { prog_usage; exit $EXIT_INVALID_OPTION; }
			if [[ "$(declare -p PKGIX_REPOS)" =~ ^"declare -a" ]]; then
				# append
				PKGIX_REPOS+=("$2")
			else
				# prepend
				PKGIX_REPOS="${2}${URL_SEP}${PKGIX_REPOS}"
			fi
			shift
			;;
		-v|--verbose) arg_verbose=1 ;;
		-q|--quiet) arg_quiet=1 ;;
		-n|--noconfirm) arg_noconfirm=1 ;;
		-d|--debug) arg_debug=1 ;;
		-h|--help) prog_usage; exit $EXIT_OK ;;
		-V|--version) prog_version; exit $EXIT_OK ;;
		--) shift; break ;;
		-*)
			expand_short_opts "rvqndhV" "$1"
			set -- "${expanded_short_opts[@]:+${expanded_short_opts[@]}}" "${@:2}"
			continue
			;;
		*) break ;;
	esac
	shift
done

sanitize_repos
cmd="${1:-}"
shift || :

#============================================================================
# Get command specific options
case "$cmd" in
	install|upgrade)
		arg_force=0
		arg_nodeps=0
		arg_reinstall=0
		arg_keep_build_dir=0
		arg_ignore_checksums=0
		arg_dry_run=0
		arg_reason_dependency=0
		arg_reason_explicit=0

		while :; do
			case "${1:-}" in
				-f|--force) arg_force=1 ;;
				-d|--nodeps) arg_nodeps=1 ;;
				-r|--reinstall) arg_reinstall=1 ;;
				-k|--keep-build-dir) arg_keep_build_dir=1 ;;
				-D|--dry) arg_dry_run=1 ;;
				--ignore-checksums) arg_ignore_checksums=1 ;;
				--asdeps) arg_reason_dependency=1 ;;
				--asexplicit) arg_reason_explicit=1 ;;
				--) shift; break ;;
				-*)
					expand_short_opts "fdrkD" "$1"
					set -- "${expanded_short_opts[@]:+${expanded_short_opts[@]}}" "${@:2}"
					continue
					;;
				*) break ;;
			esac
			shift
		done

		run_cmd "$@"
		;;
	remove)
		arg_purge=0

		while :; do
			case "${1:-}" in
				-P|--purge) arg_purge=1 ;;
				--) shift; break ;;
				-*)
					expand_short_opts "P" "$1"
					set -- "${expanded_short_opts[@]:+${expanded_short_opts[@]}}" "${@:2}"
					continue
					;;
				*) break ;;
			esac
			shift
		done

		run_cmd "$@"
		;;
	show)
		arg_list_files=0

		while :; do
			case "${1:-}" in
				-l|--list) arg_list_files=1 ;;
				--) shift; break ;;
				-*)
					expand_short_opts "l" "$1"
					set -- "${expanded_short_opts[@]:+${expanded_short_opts[@]}}" "${@:2}"
					continue
					;;
				*) break ;;
			esac
			shift
		done

		run_cmd "$@"
		;;
	list)
		arg_list_explicit=0
		arg_list_depends=0
		arg_list_unrequired=0

		while :; do
			case "${1:-}" in
				-e|--explicit) arg_list_explicit=1 ;;
				-d|--depends) arg_list_depends=1 ;;
				-u|--unrequired) arg_list_unrequired=1 ;;
				--) shift; break ;;
				-*)
					expand_short_opts "edu" "$1"
					set -- "${expanded_short_opts[@]:+${expanded_short_opts[@]}}" "${@:2}"
					continue
					;;
				*) break ;;
			esac
			shift
		done

		run_cmd "$@"
		;;
	showenv|chenv|avail)
		run_cmd "$@"
		;;
	help)
		prog_usage "$@"
		;;
	*)
		prog_usage
		exit $EXIT_INVALID_OPTION
		;;
esac

exit $EXIT_OK

# }}}

# vim: set noet foldmarker={{{,}}} foldlevel=0 fen fdm=marker :
