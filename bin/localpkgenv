#!/usr/bin/env bash

# Copyright (c) 2012, Marco Elver
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
# 
#  * Neither the name of localpkgenv nor the names of its contributors
#    may be used to endorse or promote products derived from this
#    software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# localpkgenv: Local environment and package management helper script.
#
# Author: Marco Elver <me AT marcoelver.com>
# Date: Sun 30 Sep 17:27:35 BST 2012

# Configurable variables, settable from user environment
[[ -z "$LOCALPKGENV_REPO_URLS" ]] && LOCALPKGENV_REPO_URLS="$(cd "${0%/*}"/.. && pwd)/repo"
[[ -z "$LOCALPKGENV_SHELL" ]] && LOCALPKGENV_SHELL="$SHELL"
[[ -z "$LOCALPKGENV_FETCH" ]] && LOCALPKGENV_FETCH="wget -O %s"

# LOCALPKGENV_ROOT: If set, LOCALPKGENV_ROOT is being used as the default
# root (no need to specify for each command).

# Not settable from user environment
INSTALLED_DB="var/lib/localpkgenv/installed"
URL_SEP=";"
METAPKG_DUMMY="_dummy"

msg_printf() {
	printf "\e[0;35m[localpkgenv]\e[0m ""$@" 1>&2
}

verbose_printf() {
	(( arg_verbose == 1 )) && msg_printf "$@"
}

error_printf() {
	msg_printf "\e[0;31mERROR:\e[0m ""$@"
}

warning_printf() {
	msg_printf "\e[0;31mWARNING:\e[0m ""$@"
}

# OS dependent functions
case "$OSTYPE" in
	*freebsd*|*FreeBSD*)
		platform="freebsd"

		sha256checksum() {
			sha256 "$@"
		}

		find_printbase() {
			find "$@" | sed "s:^$1::" 
		}
		;;
	*|*linux*)
		platform="$OSTYPE"

		sha256checksum() {
			sha256sum "$@"
		}

		find_printbase() {
			find "$@" -printf "%P\n"
		}
		;;
esac

remove_empty_dirs() {
	local path="$1"
	local depth="$2"
	local find_args
	[[ -z "$depth" ]] && find_args=() || find_args=("-maxdepth" "$depth")

	find "$path" "${find_args[@]}" -type d -empty -delete
}

extract_archive() {
	if [[ -f $1 ]] ; then
		msg_printf "Extracting '$1'...\n"

		case $1 in
			*.tar.bz2)  tar xjf $1   ;;
			*.tar.gz)   tar xzf $1   ;;
			*.tar.lzma) tar --lzma -xf $1 ;;
			*.tar.xz)   tar xJf $1   ;;
			*.tar)      tar xf $1    ;;
			*.tbz2)     tar xjf $1   ;;
			*.tgz)      tar xzf $1   ;;
			*.txz)      tar xJf $1   ;;
			*.bz2)      bunzip2 $1    ;;
			*.rar)      unrar x $1    ;;
			*.gz)       gunzip $1     ;;
			*.zip)      unzip $1      ;;
			*.Z)        uncompress $1 ;;
			*.7z)       7z x $1       ;;
			*)          error_printf "'$1' cannot be extracted (format unknown) !\n" ; exit 1 ;;
		esac
	else
		error_printf "'$1' is not a valid file !\n"
		exit 1
	fi
}

fetch() {
	local url="$1"
	local checksum_sha256="$2"
	local file_name="${3:-${url##*/}}"

	if [[ ! -f "$file_name" ]]; then
		if [[ "$url" =~ ^/ ]]; then
			# Is a local path, just copy
			msg_printf "Copying '$url'...\n"
			if ! cp "$url" "$file_name" &> /dev/null; then
				error_printf "Copying '$url' failed!\n"
				exit 1
			fi
		else
			local fetch_cmd
			printf -v fetch_cmd "$LOCALPKGENV_FETCH" "$file_name"
			msg_printf "Fetching '$url'...\n"
			if ! $fetch_cmd "$url"; then
				error_printf "Fetching '$url' failed!\n"
				exit 1
			fi
		fi
	fi

	local file_checksum_sha256=($(sha256checksum "$file_name"))
	file_checksum_sha256="${file_checksum_sha256[0]}"

	if [[ -n "$checksum_sha256" ]]; then
		if (( arg_ignore_checksums == 0 )); then
			if [[ "$file_checksum_sha256" != "$checksum_sha256" ]]; then
				error_printf "Checksum of '$file_name' ($file_checksum_sha256)\n              does not match ($checksum_sha256)!\n"
				exit 1
			else
				msg_printf "Valid checksum: $file_name\n"
			fi
		else
			warning_printf "Ignoring checksum for '$file_name'...\n"
		fi
	else
		if (( arg_ignore_checksums == 0 )); then
			error_printf "No checksum for '$file_name' ($file_checksum_sha256)!\n"
			exit 1
		else
			warning_printf "No checksum for '$file_name' ($file_checksum_sha256)!\n"
		fi
	fi
}

fetch_extract() {
	local url="$1"
	local checksum_sha256="$2"
	local archive_name="${3:-${url##*/}}"

	fetch "$url" "$checksum_sha256" "$archive_name"
	extract_archive "$archive_name"
}

prompt_continue() {
	(( arg_noconfirm == 1 )) && return 0

	local answer

	printf "\e[1;34mContinue ? [Y/n] \e[0m"
	read answer

	if [[ ! "$answer" =~ ^[yY]|^$ ]]; then
		msg_printf "User aborted.\n"
		return 1
	fi

	return 0
}

export_env() {
	[[ ! -d "$1" ]] && return 1

	local localenv_root="$(cd "$1" && pwd)"

	verbose_printf "Using environment: $localenv_root\n"

	# Export so calls to localpkgenv don't need the root; appending, so that 
	# installing takes the first root.
	if [[ -z "$LOCALPKGENV_ROOT" ]]; then
		export LOCALPKGENV_ROOT="$localenv_root"
	else
		export LOCALPKGENV_ROOT="$LOCALPKGENV_ROOT:${localenv_root}"
	fi

	# Prepending to PATH
	[[ -d "${localenv_root}/bin" ]] && export PATH="${localenv_root}/bin:$PATH"
	[[ -d "${localenv_root}/sbin" ]] && export PATH="${localenv_root}/sbin:$PATH"

	if [[ -d "${localenv_root}/lib" ]]; then
		# LD_LIBRARY_PATH is harmful, as it makes programs from the system use
		# the libraries found in $localenv_root/lib, which is certainly not
		# considered stable.
		# For more info: http://xahlee.info/UnixResource_dir/_/ldpath.html
		#export LD_LIBRARY_PATH="${localenv_root}/lib:$LD_LIBRARY_PATH"

		# Instead, make programs include the correct search path when they are
		# compiled (--rpath).
		export LD_RUN_PATH="${localenv_root}/lib:$LD_RUN_PATH"

		# And make the linker look in the right paths (-L)
		export LIBRARY_PATH="${localenv_root}/lib:$LIBRARY_PATH"
	fi

	[[ -d "${localenv_root}/lib/pkgconfig" ]] && export PKG_CONFIG_PATH="${localenv_root}/lib/pkgconfig:$PKG_CONFIG_PATH"

	# C/C++ preprocessor search paths (-I)
	[[ -d "${localenv_root}/include" ]] && export CPATH="${localenv_root}/include:$CPATH"

	return 0
}

cmd_showenv() {
	local localenv_root
	for localenv_root in "$@"; do
		export_env "$localenv_root"
	done

	# See export_env for why we are not exporting LD_LIBRARY_PATH

	echo "export LOCALPKGENV_ROOT=\"$LOCALPKGENV_ROOT\""
	[[ -n "$PATH" ]] && echo "export PATH=\"$PATH\""
	#[[ -n "$LD_LIBRARY_PATH" ]] && echo "export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\""
	[[ -n "$LD_RUN_PATH" ]] && echo "export LD_RUN_PATH=\"$LD_RUN_PATH\""
	[[ -n "$LIBRARY_PATH" ]] && echo "export LIBRARY_PATH=\"$LIBRARY_PATH\""
	[[ -n "$PKG_CONFIG_PATH" ]] && echo "export PKG_CONFIG_PATH=\"$PKG_CONFIG_PATH\""
	[[ -n "$CPATH" ]] && echo "export CPATH=\"$CPATH\""
}

is_pkg_pointer() {
	[[ "$(wc -l < "$1")" =~ ^[^0-9]*[01][^0-9]*$ ]]
}

source_pkg_file() {
	local pkg_file="$1"

	if is_pkg_pointer "$pkg_file"; then
		local resolved_pkg_name="$(<$pkg_file)"
		msg_printf "Points to $resolved_pkg_name\n"
		source_pkg "$resolved_pkg_name"
	else
		. "$pkg_file"
	fi
}

source_pkg() {
	local pkg_name="$1"
	local pkg_file
	local old_IFS="$IFS"
	IFS="$URL_SEP"

	# Don't set repo_url as local here, as it can then be used in the package
	# description files to get information about its source repository, and 
	# e.g., download extra files such as patches from the repo.
	for repo_url in $LOCALPKGENV_REPO_URLS; do
		pkg_file="${repo_url}/$pkg_name"

		case "$pkg_file" in
			http://*|https://*)
				local tmpfile="$(mktemp)"

				verbose_printf "Trying: $pkg_file\n"
				if wget -q -O "$tmpfile" "$pkg_file"; then
					msg_printf "Source: \e[0;32m$pkg_file\e[0m\n"
					source_pkg_file "$tmpfile"
					rm "$tmpfile"
					break
				fi
				rm "$tmpfile"
				;;
			*)
				verbose_printf "Trying: $pkg_file\n"
				if [[ -f "$pkg_file" ]]; then
					msg_printf "Source: \e[0;32m$pkg_file\e[0m\n"
					source_pkg_file "$pkg_file"
					break
				fi
				;;
		esac
	done

	IFS="$old_IFS"

	[[ -n "$version" || "$metapkg" == "$METAPKG_DUMMY" ]]
}

pkg_install() {
	local localenv_root="$1"
	local pkg_name="$2"

	if [[ ! -d "$localenv_root" ]]; then
		error_printf "'$localenv_root' is not a valid directory!\n"
		exit 1
	fi

	local db_prefix="${localenv_root}/${INSTALLED_DB}/${pkg_name}"

	if [[ -f "${db_prefix}.version" ]]; then
		msg_printf "$pkg_name is available\n"
		return 0
	fi

	# Nested, otherwise variables will get overwritten on recursive calls.
	(
		# Need to unset previous variables, otherwise we might end in an
		# endless loop when resolving dependencies

		unset metapkg
		unset satisfied
		unset version
		unset description
		unset depends
		unset iscompat
		unset isinstalled
		unset build
		unset installenv

		# Source package description file and try to traverse until a non-meta
		# package description is found.
		local next_pkg_name="$pkg_name" # preserve requested package name
		while true; do
			if ! source_pkg "$next_pkg_name"; then
				error_printf "Could not find valid package description file for '$next_pkg_name'!\n"
				exit 1
			fi

			# Not a meta-package, continue normally
			[[ -z "$metapkg" ]] && break

			# Is metapackage, check if satisfied
			if satisfied; then
				msg_printf "Metapackage '$next_pkg_name' satisfied.\n"
				exit 0
			fi

			# If this metapackage is only a dummy to check if a dependence is satisfied,
			# and the above 'satisfied' function failed, this is a dead end.
			if [[ "$metapkg" == "$METAPKG_DUMMY" ]]; then
				error_printf "Metapackage '$next_pkg_name' could not be satisfied!\n"
				exit 1
			fi

			# Not satisfied and not a dummy, resolve this by trying to install
			# the suggested package.
			msg_printf "Metapackage: $next_pkg_name -> $metapkg\n"
			next_pkg_name="$metapkg"

			# Unset meta package fields, before next iteration of source_pkg
			unset metapkg
			unset version
			unset satisfied
			unset description
		done

		# Run all commands from package description file in subshells
		# so they can't clutter the namespace.

		if ( isinstalled ); then
			if (( arg_force == 0 )); then
				msg_printf "'$pkg_name' already available outside of '$localenv_root', skipping...\n"
				exit 0
			else
				msg_printf "Forcing installation of '$pkg_name', despite already available outside of '$localenv_root'...\n"
			fi
		fi

		if ! ( iscompat ); then
			if (( arg_force == 0 )); then
				error_printf "'$pkg_name' is not compatible with your system!\n"
				exit 1
			else
				warning_printf "Trying installation of '$pkg_name', despite system incompatibility...\n"
			fi
		fi

		if (( arg_nodeps == 0 )); then
			msg_printf "Resolving $pkg_name dependencies...\n"
			local dep_name
			for dep_name in ${depends[@]}; do
				pkg_install "$localenv_root" "$dep_name"
			done
		else
			warning_printf "Ignoring dependencies.\n"
		fi

		msg_printf "Setting up $pkg_name ($version)\n"

		local build_dir="${localenv_root}/.localpkgenv-build"
		local install_dir="${localenv_root}/.localpkgenv-tmpinstall"
		mkdir -p "$build_dir"
		mkdir -p "$install_dir"

		pushd "$build_dir" &> /dev/null

		# Run build and installenv in subshells

		if ! ( build "$localenv_root" "$install_dir" ); then
			popd &> /dev/null
			(( arg_keep_build_dir == 0)) && rm -rf "$build_dir"
			rm -rf "$install_dir"
			error_printf "Building '$pkg_name' failed! Aborting.\n"
			exit 1
		fi

		if ! ( installenv "$localenv_root" "$install_dir" ); then
			popd &> /dev/null
			(( arg_keep_build_dir == 0)) && rm -rf "$build_dir"
			rm -rf "$install_dir"
			error_printf "Installation of '$pkg_name' failed! Aborting.\n"
			exit 1
		fi

		popd &> /dev/null
		(( arg_keep_build_dir == 0)) && rm -rf "$build_dir"

		# Create installed database folders
		mkdir -p "${db_prefix%/*}"

		# As prefix is $localenv_root, the complete folder structure from / is maintained inside $install_dir
		find_printbase "${install_dir}/${localenv_root}" > "${db_prefix}.files"
		cp -rp "${install_dir}/${localenv_root}"/* "${localenv_root}"
		rm -rf "$install_dir"

		echo "$version" > "${db_prefix}.version"

		# The db file is important for upgrading packages in the order they were installed!
		# As the entries are not deleted upon uninstallation, over time, a dependence ordering
		# is being built, so that if uninstalled packages are reinstalled, upgrading still
		# works as before.
		local db_file="${localenv_root}/${INSTALLED_DB}.db"

		if [[ -f "$db_file" ]] && grep -q "^.|${pkg_name}$" "$db_file"; then
			sed -i "s:^.|${pkg_name}$:i|${pkg_name}:" "$db_file"
		else
			echo "i|$pkg_name" >> "$db_file"
		fi

		msg_printf "Done installing $pkg_name ($version)\n"
	) || exit 1

	return 0
}

pkg_uninstall() {
	local localenv_root="$1"
	local pkg_name="$2"
	local db_prefix="${localenv_root}/${INSTALLED_DB}/${pkg_name}"
	local files_file="${db_prefix}.files"
	local version_file="${db_prefix}.version"

	if [[ ! -f "$files_file" ]]; then
		warning_printf "'$files_file' does not exist! Skipping...\n"
		return 1
	fi

	msg_printf "Uninstalling $pkg_name ($(<"$version_file"))...\n"

	while read filename; do
		# (1) First pass delete files and get directory depths

		if [[ ! -d "${localenv_root}/$filename" ]]; then
			rm -f "${localenv_root}/$filename"
		else
			# Get path depth for sorting: If we don't do this, directories
			# which are higher up in the hierarchy are being tried to be
			# deleted before its subdirectories, which could be empty, but
			# because the subdirectories still exist, the parent won't be
			# deleted.
			local old_IFS="$IFS"
			IFS="/"
			local tmp=(${filename[@]})
			printf "${#tmp[@]}:${filename}\n"
			IFS="$old_IFS"
		fi
	done < "$files_file" | sort -rn |
	while read filename; do
		# (2) Then check for empty directories and delete if empty
		filename="${filename#*:}"
		remove_empty_dirs "${localenv_root}/$filename" 0
	done

	# Remove meta files
	rm "$files_file"
	rm "$version_file"

	# Clean up installed db
	remove_empty_dirs "${localenv_root}/${INSTALLED_DB}"

	# Set package as uninstalled
	sed -i "s:^.|${pkg_name}$:u|${pkg_name}:" "${localenv_root}/${INSTALLED_DB}.db"

	msg_printf "Done uninstalling $pkg_name\n"
}

cmd_install() {
	if [[ -z "$1" ]]; then
		error_printf "You need to specify a locakpkgenv root!\n"
		exit 1
	fi

	local localenv_root="$1"
	shift

	if [[ -z "$1" ]]; then
		error_printf "You need to specify at least one package to install.\n"
		exit 1
	fi

	if [[ ! -d "${localenv_root}" ]]; then
		if ! mkdir -p "${localenv_root}" 2> /dev/null; then
			error_printf "Could not create directory '$localenv_root'!\n"
			exit 1
		fi
	fi

	localenv_root="$(cd "$localenv_root" && pwd)"
	export_env "$localenv_root"

	msg_printf "Installing into $localenv_root: $*\n"

	prompt_continue || exit 1

	local pkg_name
	for pkg_name in "$@"; do
		pkg_install "$localenv_root" "$pkg_name"
	done
}

root_upgrade() {
	local localenv_root="$1"

	if [[ ! -f "${localenv_root}/${INSTALLED_DB}.db" ]]; then
		error_printf "'$localenv_root' is not a valid localpkgenv root!\n"
		exit 1
	fi

	localenv_root="$(cd "$localenv_root" && pwd)"
	export_env "$localenv_root"

	msg_printf "Upgrading $localenv_root ...\n"

	prompt_continue || exit 1

	grep "^i|" "${localenv_root}/${INSTALLED_DB}.db" |
	while read pkg_name; do
		pkg_name="${pkg_name##i|}"
		version_file="${localenv_root}/${INSTALLED_DB}/${pkg_name}.version"

		if [[ ! -f "$version_file" ]]; then
			warning_printf "Inconsistent database: no metadata for '$pkg_name'\n"
			continue
		fi

		installed_version="$(<$version_file)"

		if ! (
			if ! source_pkg "$pkg_name"; then
				warning_printf "Could not find package description file for '$pkg_name', skipping upgrade...\n"
				exit 0
			fi

			if [[ "$version" != "$installed_version" ]]; then
				msg_printf "\e[0;33mUpgrading\e[0m $pkg_name ($installed_version -> $version)\n"
				exit 1
			else
				exit 0
			fi
		); then
			pkg_uninstall "$localenv_root" "$pkg_name"
			pkg_install "$localenv_root" "$pkg_name"
		else
			msg_printf "$pkg_name ($installed_version) is up to date\n"
		fi
	done

	msg_printf "Done upgrading.\n"
}

cmd_upgrade() {
	if [[ -z "$1" ]]; then
		error_printf "You need to specify at least one locakpkgenv root!\n"
		exit 1
	fi

	local localenv_root
	for localenv_root in "$@"; do
		# Run nested, not to pollute subsequent upgrades with export_env
		# The environment should be set accordingly prior to upgrading!
		( root_upgrade "$localenv_root" )
	done
}

cmd_uninstall() {
	local localenv_root="$1"
	shift

	if [[ ! -d "$localenv_root" ]]; then
		error_printf "'$localenv_root' is not a valid directory!\n"
		exit 1
	fi

	localenv_root="$(cd "$localenv_root" && pwd)"

	msg_printf "Uninstalling from $localenv_root: $*\n"
	prompt_continue || exit 1
	
	local pkg_name
	for pkg_name in "$@"; do
		pkg_uninstall "$localenv_root" "$pkg_name"
	done
}

cmd_avail() {
	local old_IFS="$IFS"
	IFS="$URL_SEP"

	local repo_url
	for repo_url in $LOCALPKGENV_REPO_URLS; do
		printf "\e[1;34m-> \e[1;32m${repo_url}\e[0m\n"
		case "$repo_url" in
			http://*|https://*)
				msg_printf "Listing packages for a HTTP repository is not supported!\n"
				;;
			*)
				# Don't show hidden files
				find_printbase "$repo_url" \( -type f -o -type l \) -a ! -name ".*" 2> /dev/null | sort |
				while read pkg_name; do
					if is_pkg_pointer "${repo_url}/$pkg_name"; then
						printf "%-42s %-18s %s\n" "$pkg_name" "->" "$(<"${repo_url}/$pkg_name")"
					else
						(
							. "${repo_url}/$pkg_name"
							printf "%-42s %-18s %s\n" "$pkg_name" "$version" "$description"
						)
					fi
				done
				;;
		esac
	done

	IFS="$old_IFS"
}

cmd_list() {
	local localenv_root
	for localenv_root in "$@"; do
		if [[ -d "$localenv_root" ]]; then
			localenv_root="$(cd "$localenv_root" && pwd)"
			printf "\e[1;32m${localenv_root}\e[0m\n"

			if [[ -d "${localenv_root}/${INSTALLED_DB}" ]]; then
				find "${localenv_root}/${INSTALLED_DB}" -type f -name "*.version" | sort |
				while read version_file; do
					pkg_name="${version_file##${localenv_root}/${INSTALLED_DB}/}"
					pkg_name="${pkg_name%%.version}"

					printf "${pkg_name} $(<$version_file)\n"
				done
			fi
		fi
	done
}

cmd_chenv() {
	local localenv_root
	for localenv_root in "$@"; do
		export_env "$localenv_root"
	done

	msg_printf "Spawning shell\n"
	exec "$LOCALPKGENV_SHELL"
}

sanitize_repo_urls() {
	local old_repo_urls="$LOCALPKGENV_REPO_URLS"
	local old_IFS="$IFS"
	IFS="$URL_SEP"

	LOCALPKGENV_REPO_URLS=""

	local url
	for url in $old_repo_urls; do
		[[ "$url" =~ ^file:// ]] && url="${url##file://}"
		url=${url%%/}

		LOCALPKGENV_REPO_URLS+="${url};"
	done

	IFS="$old_IFS"
}

# Get command line options
arg_verbose=0
arg_noconfirm=0

while true; do
	case "$1" in
		-r|--repo-urls)
			LOCALPKGENV_REPO_URLS="$2;$LOCALPKGENV_REPO_URLS"
			shift 2
			;;
		-v|--verbose) arg_verbose=1 ; shift ;;
		-n|--noconfirm) arg_noconfirm=1 ; shift ;;
		*)
			break
			;;
	esac
done

sanitize_repo_urls

cmd=$1
shift
case "$cmd" in
	install|upgrade)
		arg_force=0
		arg_nodeps=0
		arg_keep_build_dir=0
		arg_ignore_checksums=0

		while true; do
			case "$1" in
				-f|--force) arg_force=1 ; shift ;;
				-d|--nodeps) arg_nodeps=1 ; shift ;;
				--keep-build-dir) arg_keep_build_dir=1 ; shift ;;
				--ignore-checksums) arg_ignore_checksums=1 ; shift ;;
				*) break ;;
			esac
		done

		;;& # Evaluate next statements!
	install|uninstall)
		if [[ -z "$LOCALPKGENV_ROOT" ]]; then
			cmd_$cmd "$@"
		else
			# Commands which can only accept one root, pass first one only
			# Remove leading ':'
			args_root="${LOCALPKGENV_ROOT##:}"
			cmd_$cmd "${args_root%%:*}" "$@"
		fi
		;;
	upgrade|list|showenv|chenv)
		if [[ -z "$LOCALPKGENV_ROOT" ]]; then
			cmd_$cmd "$@"
		else
			old_IFS="$IFS"
			IFS=":"
			args_root=(${LOCALPKGENV_ROOT[@]})
			IFS="$old_IFS"
			unset old_IFS
			cmd_$cmd "${args_root[@]}" "$@"
		fi
		;;
	avail)
		cmd_$cmd "$@"
		;;
	help)
		case "$1" in
			install|upgrade)
				cat <<EOF
Usage: localpkgenv $1 [-f|--force] [-d|--nodeps] [--keep-build-dir]
                   [--ignore-checksums]
                   <localenv-dir> <pkgs>...

Options:
    -f, --force
        Force installation of programs that are: already available outside of
        <localenv-dir>; incompatible with the current system.
    -d, --nodeps
        Ignore dependenciy check and do not install dependencies.
    --keep-build-dir
        Keeps the build directory.
    --ignore-checksums
        Ignores checksums for remotely fetched files.
EOF
				;;
			uninstall|avail|list|showenv|chenv|help)
				echo "No further information available."
				;;
			*)
				echo "Please specify valid command."
				;;
		esac
		;;
	*)
		cat <<EOF
Usage: localpkgenv [-r|--repo-urls] [-n|--noconfirm] [-v|--verbose]
                   <command> [<args>]

Commands available:
    install    Install a package in a local environment
    upgrade    Upgrade a local environment
    uninstall  Uninstall an installed package
    avail      List packages available to install
    list       List installed packages in environments
    showenv    Show local environment parameters
    chenv      Switch to a local environment

Options:
   -r, --repo-urls
       Specify additional package repository URL; use "$URL_SEP" to separate multiple repositories.
       Currently supported protocols are: file://, http://, https://
   -n, --noconfirm
       Proceed without asking the user for confirmation.
   -v, --verbose
       Be more verbose.

See 'localpkgenv help <command>' for more information on a command.
EOF
		;;
esac

