#!/bin/bash

# Copyright (c) 2012, Marco Elver
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
# 
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 
#  * Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
# 
#  * Neither the name of localpkgenv nor the names of its contributors
#    may be used to endorse or promote products derived from this
#    software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# localpkgenv: Local environment and package management helper script.
#
# Author: Marco Elver <me AT marcoelver.com>
# Date: Sun 30 Sep 17:27:35 BST 2012

[[ -z "$REPO_URLS" ]] && REPO_URLS="$(cd `dirname $0`/.. && pwd)/repo"
INSTALLED_DIR="var/lib/localpkgenv/installed"
URL_SEP=";"

msg_printf() {
	printf "\e[0;35m[localpkgenv]\e[0m ""$@"
}

error_printf() {
	msg_printf "\e[0;31mERROR:\e[0m ""$@"
}

warning_printf() {
	msg_printf "\e[0;31mWARNING:\e[0m ""$@"
}

extract_archive() {
  if [[ -f $1 ]] ; then
	msg_printf "Extracting '$1' ...\n"

    case $1 in
      *.tar.bz2)   tar xjf $1   ;;
      *.tar.gz)    tar xzf $1   ;;
      *.tar.lzma)  tar --lzma -xf $1 ;;
      *.tar.xz)    tar xJf $1   ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.txz)       tar xJf $1   ;;
      *.bz2)       bunzip2 $1    ;;
      *.rar)       unrar x $1    ;;
      *.gz)        gunzip $1     ;;
      *.zip)       unzip $1      ;;
      *.Z)         uncompress $1 ;;
      *.7z)        7z x $1       ;;
      *)           error_printf "'$1' cannot be extracted (format unknown) !\n" ; exit 1 ;;
    esac
  else
    error_printf "'$1' is not a valid file !\n"
	exit 1
  fi
}

fetch() {
	local url="$1"
	local checksum_sha256="$2"
	local file_name="$(basename "$url")"

	if [[ ! -f "$file_name" ]]; then
		wget "$url" || exit 1
	fi

	local file_checksum_sha256="$(sha256sum "$file_name" | cut -d " " -f 1)"

	if [[ -n "$checksum_sha256" ]]; then
		if (( arg_ignore_checksums == 0 )); then
			if [[ "$file_checksum_sha256" != "$checksum_sha256" ]]; then
				error_printf "Checksum of '$file_name' ($file_checksum_sha256) does not match ($checksum_sha256)!\n"
				exit 1
			else
				msg_printf "Checksum for '$file_name' matches.\n"
			fi
		else
			warning_printf "Ignoring checksum for '$file_name'.\n"
		fi
	else
		if (( arg_ignore_checksums == 0 )); then
			error_printf "No checksum for '$file_name' ($file_checksum_sha256)!\n"
			exit 1
		else
			warning_printf "No checksum for '$file_name' ($file_checksum_sha256)!\n"
		fi
	fi
}

fetch_extract() {
	local url="$1"
	local checksum_sha256="$2"
	local archive_name="$(basename "$url")"

	fetch "$url" "$checksum_sha256"
	extract_archive "$archive_name"
}

export_env() {
	[[ ! -d "$1" ]] && return 1

	local base_path="$(cd "$1" &> /dev/null && pwd)"

	export LOCALENV_ROOT="${base_path}:$LOCALENV_ROOT"
	export PATH="${base_path}/bin:$PATH"
	export LD_LIBRARY_PATH="${base_path}/lib:$LD_LIBRARY_PATH"

	return 0
}

source_pkg_file() {
	local pkg_file="$1"

	if [[ "$(wc -l "$pkg_file" | cut -d " " -f 1)" == "0" ]]; then
		local ref_pkg_name="$(<$pkg_file)"
		msg_printf "Found reference to $ref_pkg_name, resolving ...\n"
		source_pkg "$ref_pkg_name"
	else
		. "$pkg_file"
	fi
}

source_pkg() {
	local pkg_name="$1"
	local pkg_file
	local old_IFS=$IFS
	IFS=$URL_SEP

	for repo_url in $REPO_URLS; do
		pkg_file="${repo_url}/$pkg_name"

		case "$pkg_file" in
			http://*|https://*)
				local tmpfile="$(mktemp)"

				msg_printf "Trying $pkg_file\n"
				if wget -q -O "$tmpfile" "$pkg_file"; then
					msg_printf "Using \e[0;32m$pkg_file\e[0m\n"
					source_pkg_file "$tmpfile"
					rm "$tmpfile"
					break
				fi
				rm "$tmpfile"
				;;
			*)
				msg_printf "Trying $pkg_file\n"
				if [[ -f "$pkg_file" ]]; then
					msg_printf "Using \e[0;32m$pkg_file\e[0m\n"
					source_pkg_file "$pkg_file"
					break
				fi
				;;
		esac
	done

	IFS=$old_IFS

	[[ -n "$version" ]]
}

pkg_install() {
	local localenv_root="$1"
	local pkg_name="$2"

	if [[ -f "${localenv_root}/${INSTALLED_DIR}/${pkg_name}.version" ]]; then
		msg_printf "$pkg_name is available\n"
		return 0
	fi

	(
		if ! source_pkg "$pkg_name"; then
			error_printf "Could not find package description file for '$pkg_name'!\n"
			exit 1
		fi
		
		if (( arg_force == 0 )); then
			if is_installed; then
				msg_printf "'$pkg_name' already available outside of '$localenv_root', skipping ...\n"
				exit 0
			fi
		else
			if is_installed; then
				msg_printf "Forcing installation of '$pkg_name', despite already available outside of '$localenv_root' ...\n"
			fi
		fi

		if (( arg_nodeps == 0 )); then
			msg_printf "Resolving $pkg_name dependencies ...\n"
			for dep_name in ${depends[@]}; do
				pkg_install "$localenv_root" "$dep_name"
			done
		else
			warning_printf "Ignoring dependencies.\n"
		fi

		msg_printf "Installing $pkg_name ($version)\n"

		local build_dir="${localenv_root}/.localpkgenv-build"
		local install_dir="${localenv_root}/.localpkgenv-tmpinstall"
		mkdir -p "$build_dir"
		mkdir -p "$install_dir"

		pushd "$build_dir" &> /dev/null

		if ! build "$localenv_root" "$install_dir" ; then
			popd &> /dev/null
			(( arg_keep_build_dir == 0)) && rm -rf "$build_dir"
			rm -rf "$install_dir"
			error_printf "Installation of '$pkg_name' failed! Aborting.\n"
			exit 1
		fi

		popd &> /dev/null
		(( arg_keep_build_dir == 0)) && rm -rf "$build_dir"

		# As prefix is $localenv_root, the complete folder structure from / is maintained inside $install_dir
		find "${install_dir}/${localenv_root}" \( -type f -o -type l \) -printf "%P\n" > "${localenv_root}/${INSTALLED_DIR}/${pkg_name}.files"
		cp -rp "${install_dir}/${localenv_root}"/* "${localenv_root}"
		rm -rf "$install_dir"

		echo "$version" > "${localenv_root}/${INSTALLED_DIR}/${pkg_name}.version"

		printf "\e[0;36m============================================================\e[0m\n"
	) || exit 1

	return 0
}

cmd_install() {
	arg_force=0
	arg_nodeps=0
	arg_keep_build_dir=0
	arg_ignore_checksums=0

	while true; do
		case "$1" in
			-f|--force) arg_force=1 ; shift ;;
			-d|--nodeps) arg_nodeps=1 ; shift ;;
			--keep-build-dir) arg_keep_build_dir=1 ; shift ;;
			--ignore-checksums) arg_ignore_checksums=1 ; shift ;;
			*) break ;;
		esac
	done

	local localenv_root="$1"
	shift

	if [[ -z "$1" ]]; then
		msg_printf "You need to specify at least one package to install.\n"
		exit 1
	fi

	[[ ! -d "${localenv_root}/${INSTALLED_DIR}" ]] && mkdir -p "${localenv_root}/${INSTALLED_DIR}"
	localenv_root="$(cd "$localenv_root" && pwd)"

	export_env "$localenv_root"

	for pkg_name in "$@"; do
		pkg_install "$localenv_root" "$pkg_name"
	done
}

cmd_upgrade() {
	if [[ ! -d "$1" ]]; then
		error_printf "'$1' is not a valid directory!\n"
		exit 1
	fi

	local localenv_root="$1"
	shift

	find "${localenv_root}/${INSTALLED_DIR}" -type f -name "*.version" |
	while read installed_pkg_versionfile; do
		pkg_name="$(basename "$installed_pkg_versionfile" ".version")"
		installed_version="$(<$installed_pkg_versionfile)"

		if ! (
			if ! source_pkg "$pkg_name"; then
				warning_printf "Could not find package description file for '$pkg_name', skipping upgrade ...\n"
				exit 0
			fi

			if [[ "$version" != "$installed_version" ]]; then
				msg_printf "\e[0;33mUpgrading\e[0m $pkg_name ($installed_version -> $version)\n"
				exit 1
			else
				exit 0
			fi
		); then
			cmd_uninstall "$localenv_root" "$pkg_name"
			cmd_install "$localenv_root" "$pkg_name"
		else
			msg_printf "$pkg_name ($installed_version) is up to date\n"
		fi
	done
}

remove_empty_dirs() {
	find "$1" -type d -empty -delete -a -printf "deleted dir %p\n" 2> /dev/null
}

cmd_uninstall() {
	if [[ ! -d "$1" ]]; then
		error_printf "'$1' is not a valid directory!\n"
		exit 1
	fi

	local localenv_root="$1"
	shift
	local install_file
	
	for pkg_name in "$@"; do
		install_file="${localenv_root}/${INSTALLED_DIR}/${pkg_name}.files"

		if [[ ! -f "$install_file" ]]; then
			warning_printf "'$install_file' does not exist! Skipping ...\n"
			continue
		fi

		msg_printf "Uninstalling $pkg_name ...\n"

		while read filename; do
			rm -fv "${localenv_root}/$filename"
		done < "$install_file"

		rm -fv "$install_file"
		rm -fv "${localenv_root}/${INSTALLED_DIR}/${pkg_name}.version"

		remove_empty_dirs "$localenv_root"
	done
}

cmd_avail() {
	local old_IFS=$IFS
	IFS=$URL_SEP

	for repo_url in $REPO_URLS; do
		echo "Available package listing for $repo_url"
		case "$repo_url" in
			http://*|https://*)
				msg_printf "Listing packages for a HTTP repository is not supported!\n"
				;;
			*)
				# Don't show hidden files
				find "$repo_url" \( -type f -o -type l \) -a ! -name ".*" -printf "%P\n" 2> /dev/null | sort |
				while read pkg_name; do
					printf '%-25s : ' "$pkg_name"
					( . "${repo_url}/$pkg_name"; echo "$description" )
				done
				;;
		esac
		echo "----------------------------------------------------------------------"
	done

	IFS=$old_IFS
}

cmd_list() {
	msg_printf "Installed packages:\n"
	for localenv_root in "$@"; do
		if export_env "$localenv_root"; then
			printf "[%-68s]\n" "${localenv_root%%/}"
			if [[ -d "${localenv_root}/${INSTALLED_DIR}" ]]; then
				find "${localenv_root}/${INSTALLED_DIR}" -type f -name "*.version" |
				while read installed_pkg_versionfile; do
					installed_pkg_name="$(basename "$installed_pkg_versionfile" ".version")"
					echo "${installed_pkg_name} ($(<$installed_pkg_versionfile))"
				done
			fi
			echo "----------------------------------------------------------------------"
		fi
	done
}

cmd_showenv() {
	for localenv_root in "$@"; do
		export_env "$localenv_root"
	done

	echo "export LOCALENV_ROOT=\"$LOCALENV_ROOT\""
	echo "export PATH=\"$PATH\""
	echo "export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\""
}

cmd_chenv() {
	cmd_list "$@"

	local script_stat=($(</proc/$$/stat))    # create an array
	local parent_pid=${script_stat[3]}

	msg_printf "Spawning shell\n"
	if [[ -x "/proc/${parent_pid}/exe" ]]; then
		exec "/proc/${parent_pid}/exe"
	else
		exec "$SHELL"
	fi
}

sanitize_repo_urls() {
	local old_repo_urls="$REPO_URLS"
	local old_IFS=$IFS
	IFS=$URL_SEP

	REPO_URLS=""

	for url in $old_repo_urls; do
		[[ "$url" =~ ^file:// ]] && url="${url##file://}"
		url=${url%%/}

		REPO_URLS+="${url};"
	done

	IFS=$old_IFS
}

# Get command line options
while true; do
	case "$1" in
		-r|--repo-urls)
			REPO_URLS="$2;$REPO_URLS"
			shift 2
			;;
		*)
			break
			;;
	esac
done

sanitize_repo_urls

case "$1" in
	install) shift; cmd_install "$@" ;;
	upgrade) shift; cmd_upgrade "$@" ;;
	uninstall) shift; cmd_uninstall "$@" ;;
	avail)    shift; cmd_avail "$@" ;;
	list) shift; cmd_list "$@" ;;
	showenv)  shift; cmd_showenv "$@" ;;
	chenv)  shift; cmd_chenv "$@" ;;
	help)
		case "$2" in
			install)
				cat <<EOF
Usage: localpkgenv install [-f|--force] [-d|--nodeps] [--keep-build-dir]
                   [--ignore-checksums]
                   <localenv-dir> <pkgs>...

Options:
    -f, --force
        Force installation of programs that are already available outside of
        <localenv-dir>.
    -d, --nodeps
        Ignore dependenciy check and do not install dependencies.
    --keep-build-dir
        Keeps the build directory.
    --ignore-checksums
        Ignores checksums for remotely fetched files.
EOF
				;;
			upgrade|uninstall|avail|list|showenv|chenv|help)
				echo "No further information available."
				;;
			*)
				echo "Please specify valid command."
				;;
		esac
		;;
	*)
		cat <<EOF
Usage: localpkgenv [-p|--pkgpath] <command> [<args>]

Commands available:
    install    Install a package in a local environment
    upgrade    Upgrade a local environment
    uninstall  Uninstall an installed package
    avail      List packages available to install
    list       List installed packages in environments
    showenv    Show local environment parameters
    chenv      Switch to a local environment

Options:
   -r, --repo-urls
       Specify additional package repository URL; use "$URL_SEP" to separate multiple repositories.
       Currently supported protocols are: file://, http://, https://

See '$0 help <command>' for more information on a command.
EOF
		;;
esac

